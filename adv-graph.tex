%\documentclass[main.tex]{subfiles}
\documentclass[a4paper,12pt]{book}
\input{npsc.tex}  % by little fish (will be the deprecated doc-style)
\input{ioicamp.tex}  % modifications for ioicamp


\begin{document}


\newcommand{\str}[1]{\texttt{"#1"}}
\newcommand{\mcstr}[2]{\texttt{"#1}\cdots\texttt{#2"}}
\newcommand{\ord}[1]{\opord\left(#1\right)}
\newcommand{\abs}[1]{\lvert #1 \rvert}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\ceil}[1]{\lceil #1 \rceil}
\newcommand{\opord}{\operatorname{\mathcal{O}}}
\newcommand{\fail}{\operatorname{\mathcal{F}}}
\newcommand{\flk}{\operatorname{\mathfrak{F}}}
\newcommand{\suf}{\operatorname{\sigma}}
\newcommand{\rank}{\operatorname{\mathcal{R}}}
\newcommand{\sa}{\operatorname{\mathcal{SA}}}
\newcommand{\hei}{\operatorname{\mathcal{H}}}
\newcommand{\edps}{\operatorname{\mathcal{E}}}
\newcommand{\mx}{\operatorname{\mathcal{M}}}
\newcommand{\argmax}{\operatorname{arg\,max}}
\newcommand{\cons}[1]{\left[ \: #1 \: \right]}

\newcommand\numbereqn{\addtocounter{equation}{1}\tag{\theequation}}
\newcommand\listeqn{\hfill\refstepcounter{equation}(\theequation)}
\newenvironment{monobox}{\linespread{0.6}\Verbatim[frame=single, commandchars=\\\{\}]}{\endVerbatim}
\makeatletter

\NewChapter{進階圖論}{Advanced Graph Theory} 

\section{圖的種類}
\subsection{樹}
一個沒有環的連通圖就是一棵樹。相信大家對樹的性質都已經很熟悉，因此
這邊介紹一些進階的技巧。

\subsubsection{樹的子樹區間}
俗稱的「把樹壓平」，其實就是希望對於每一個點 $v$ ，都定出 $L_v, R_v$，
使得如果 $u$ 在 $v$ 的子樹下，有 $[L_u, R_u] \subset [L_v, R_v]$，也就是
$L_v \leq L_u \leq R_u \leq R_v$。
\begin{theorem}[樹的子樹區間]
  $\texttt{}$ 我們可以用以下方法得到 $L_v, R_v$，維護一個計數器 \texttt{cnt}
  ，一開始 $\texttt{cnt} = 0$並從根開始 DFS。
  \begin{itemize}
      \item 當第一次到一個點 $v$ 時，就讓 $L_v = \texttt{cnt}$。
      \item 當離開一個點 $u$ 時，就讓 $R_v = \texttt{cnt}$，然後 $\texttt{cnt}
          \gets \texttt{cnt} + 1$。
  \end{itemize}
  得出的 $L_v, R_v$ 便是一個合理的子樹區間。
\end{theorem}
這可以用來解決不少區間查尋的問題

\SampleProblem[經典問題]{樹上查詢}{
	給定一棵$N$個點的有根帶點權樹，接著$Q$個操作，每次操作可能是：
	\begin{itemize}
	\item \InlineCode$add x c$: 把以$x$為根的子樹的所有節點權重同加上$c$
	\item \InlineCode$change x c$: 把以$x$為根的子樹的所有節點權重變成$c$
	\item \InlineCode$query x$: 詢問以$x$為根的子樹的權重最大值。
	\end{itemize}
	$1 \le N, Q \le 100000$
}
用上述的方法將樹做子樹區間，原本的題目就變成是在區間上做一些查詢或是修改，
用線段樹等等的資料結構處理即可。

\subsubsection{樹分治}
就是在樹上使用分治法，對於一棵樹，每次選擇 $v$ 一個點拔掉，將原來的樹
分成很多個子樹，並對這些子樹遞迴求解。最後再將這些子樹合併回去。
複雜度為
\begin{equation}
  T(n) = \sum T(m_i) + f(n)
\end{equation}
其中 $m_i$ 表示各個子樹的大小，$\sum m_i = n - 1$，
而 $f(n)$ 是合併所需的時間。
而這個複雜度跟 $\max m_i$ 非常相關，\\
如果 $\max m_i \leq n / 2$ ，那通常就有不錯的複雜度，比如
$f(n) = n$ 則 $T(n) = n \log n$。因此 $v$ 的選擇就很重要了，
要滿足拔掉 $v$ 後剩下的子樹都不會太大。事實上有以下定理。

\begin{theorem}
  所有樹都有{\bf 重心}。一個點是重心表示拔掉他之後所有的
  子樹的大小都不超過原來的樹大小的一半。
\end{theorem}
\begin{proof}
  定義 $c(v)$ 為 $v$ 到所有其他點的距離的合。則使 $c(u)$ 最小
  的那個點一定是重心。否則假設本來 $(u, v)$ 相鄰，且拔掉 $u$ 
  後 $v$ 所屬的子樹的大小大於一半，比較 $c(u), c(v)$ 可以發現
  有超過一半的點到 $u$ 的距離比到 $v$ 近 $1$，而不超過一半的點
  距離遠了 $1$，\\因此 $c(v) < c(u)$ \contradict。
\end{proof}

\SampleProblem[POJ 1741]{Tree}{
  給一棵樹，樹的邊有權重表示距離，求距離不超過 $k$ 的點對數。
  ($\ord{n \log^{\ord{1}} n}$)
}
用樹分治的想法，我們就只需要考慮如何在線性時間合併子樹即可。
對於每個子樹我們可以先做一次 BFS 找出每個點到當前重心 $v$ 的
距離，而合併兩個子樹 $T_1, T_2$ 其實就是在問對於所有 $u_1 \in T_1$，
有多少 $u_2 \in T_2$ 滿足 $d(u_2, v) \leq k - d(u_1, v)$。這個可用
一些如線段樹等的資料結構在 $\ord{n \log n}$ 時間完成(事實上花點巧思，
可以用雙指針在線性時間內做到)。總時間複雜度就是 $\ord{n \log^2 n}$。

\subsubsection{啟發式合併}
樹分治因為對最大子樹的大小有限制，所以必需額外進行找重心的動作，
有點麻煩。不過再某些情況下可以用啟發式合併的方法簡化。

更詳細的說，如果合併兩個子樹 $T_1, T_2$ 的複雜度「幾乎」只和一者的
大小有關，如 $\ord{T_2}, \ord{T_2 \log T_1}$ 等等，那麼可以證明每
次合併子樹時，找最大的子樹 $T_1$，把其他的子樹合併進來，就會有不錯的
複雜度。

\begin{theorem}
  假設合併兩個子樹 $T_1, T_2$ 的複雜度為 $\ord{T_2 f(n)}$，如果用上
  述的方法，則整體的複雜度是 $\ord{n \log(n) f(n)}$。
\end{theorem}
\begin{proof}
  合併兩個子樹 $T_1, T_2$ 的複雜度為 $\ord{T_2 f(n)}$，可以想作
  把 $T_2$ 裡的點都丟到 $T_1$ 去，且丟一個點的平均複雜度是
  $f(n)$。現在一個點被丟到的新的子樹，表示他原來所屬的
  子樹大小比當前最大的子樹還小，因此合併後他所屬的新子樹會
  至少是原來的一半，因此每個點最多被丟到新的子樹 $\ord{\log n}$ 次，
  因此總複雜度是 $n \log(n) f(n)$。
\end{proof}

\subsection{平面圖}
{\bf 平面圖}就是可以畫在平面上的圖，使得任兩個邊只會在點上相交而已。

而平面圖有一個很重要的定理。
\begin{theorem}[定理 (歐拉定理)]
  對於一個{\bf 連通}的平面圖，有
  \begin{equation}
    E = V + F - 2 \label{eq:planar-euler}
  \end{equation}
  其中 $E, V, F$ 分別代表圖的邊數、點數還有面數。
  一個{\bf 面}定義為被邊所切出的一個區域(包含最外面的無限區域)。
\end{theorem}
歐拉公式給出了平面圖邊和點的關係式。而從公式中也可以看出平面圖邊的個數
不會太多！事實上對於一個簡單的平面圖，有以下定理：
\begin{theorem}[定理]
  對於一個{\bf 簡單連通}的平面圖，如果 $\abs{V} \geq 3$ 則有
  \begin{equation}
    \abs{E} \leq 3\abs{V} - 6 \label{eq:planar-2}
  \end{equation}
\end{theorem}
\begin{proof}
  由 \eqref{eq:planar-euler}，$\abs{E} = \abs{V} + \abs{F} - 2$。
  但簡單圖沒有自環及重邊，一個面一定至少有三條邊， $\abs{F} \geq 3 \abs{E}$。
  代入 \eqref{eq:planar-euler} 得 $\abs{E} \leq 3 \abs{V} - 6$。
\end{proof}

邊很少的這個條件往往是解題的關鍵！

\SampleProblem[NTUJ 2126]{Defense Your Country}{%
  給你一個平面圖，請找一個最大團，也就是
  最大的一個完全子圖。 ($\abs{V} \leq 2 \cdot 10^5$)
}
一看這個題目，不得了，連 $\abs{E}$ 都沒有給，但不要忘了由 \eqref{eq:planar-2}
邊的數量不會超過 $3$ 倍的 $\abs{V}$。 

而最大團是個 $\NPC$ 問題，如果我們不善用平面圖的性質，肯定解不出來。
注意到 {\bf 平面圖的子圖仍是平面圖}，而完全圖的邊的數量 
$\ord{E} = \ord{V^2}$，平面圖的是 $\ord{E} = \ord{V}$。
肯定{\bf 有個上界 $m$，$K_m$ 絕對不會出現在平面圖上}。
事實上算一下會發現對於 $K_5$，邊有 $10$ 條，點有 $5$ 個，而
$10 > 3 \cdot 5 - 6 = 9$，所以根據 \eqref{eq:planar-2}， $K_5$ 肯定不是平面圖
！因此平面圖的最大團一定不超過 $4$。

不過這題還沒有結束，雖然我們只要檢查 $4$ 個點以下的完全圖，但還是
要有一個有效率的方法，否則 $\ord{V^4}$ 枚舉肯定要超時。再注意到
\eqref{eq:planar-2} 其實告訴了
\[ \sum \deg(v) = 2E \leq 6V - 12.\]
因此 $\deg(v)$ 的平均值小於 $6$ ，也就是一定有一個點的度數小於 $5$，
所以我們可以先找一個 $v_1$ 使得 $\deg(v_1) \leq 5$ ，然後 $2^6$ 枚舉
他和他的鄰居的最大團就可以了。枚舉完了這個點，將這個點從圖上移除，
新的圖仍是一個平面圖，因此我們又可以再找一個 $v_2$ 使得
$\deg(v_2) \leq 5$。一路做下去我們就得到了一個 $\ord{V}$ 的做法！

這裡再總結一下平面圖的一些結論。

\begin{theorem}[定理]
  定義一個圖的 degeneracy 為 $\min \deg(v)$，則平面圖的 degeneracy $\leq 5$。
\end{theorem}

\begin{theorem}[定理]
  一個圖是平面圖的條件若且唯若 $K_5, K_{3, 3}$ 不是他的 minor。
  $G$ 是 $H$ 的 minor 表示 $G$ 可以由
  \begin{itemize}
    \item 刪掉一條邊
    \item 刪掉一個點
    \item 收縮一條邊，也就是把兩個點合併。
  \end{itemize}
  得到。
\end{theorem}

\subsection{競賽圖}
一個競賽圖是一個有向圖，且 $(u, v), (v, u)$ 恰好有一個在 $E$ 中。
可以想成是「有向完全圖」。競賽圖也有許多有趣的性質，如以下這個例題。

\SampleProblem{競賽圖的 Hamilton Path}{
  給你一個競賽圖，求他的 Hamilton Path。
}
如果你把競賽圖想成是「兩兩對局結果」，也就是如果 $u \to v$
就表示 $u$ 贏 $v$，那一個 Hamilton path 其實就是一個「幾乎」
\footnote{會說「幾乎」的原因是因為這個關係不一定有傳遞性，也就是
$(u \to v) \land (v \to w) \centernot\implies u \to w$。}
正確的強度順序，因此我們不如往排序的方向想。

而眾多排序法，大家第一個想到的應該是最常用的快速排序法。我們可以
模仿快速排序法的方法，先隨便挑一個點 $v$ 出來，之後把所有他「贏過」
的點 $u$ 挑出來，也就是 $v \to u \in E$ 的點。假說這個集合是 $A$，
那 $\bar{A} \setminus v$ 裡的點 $w$ 由競賽圖的性質可以知道 
$w \to v \in E$，因此我們只要遞迴下去做 $A, \bar{A}$，最後用
$v$ 這個點把他們兩個的 Hamilton path 串起來就可以了！

有趣的是這題用「幾乎所有的排序法」都會對，如 Merge sort 或是 
Insertion sort 等等。

\subsection{二分圖}
如果一個圖可以被分成兩個點集 $U, V$ 使得任兩個點 $u, v$ 如果在
同一個集合的話，他們之間一定沒有邊，即 $(u, v) \notin E$，則我們
就稱這個圖是一個二分圖。這也等價於可以被二著色，且相鄰的點不同色。

要判斷一個圖是否是二分圖，一個最簡單的方法就是把這個二分圖遞迴黑白染色，
也就是從一個點 $u$ 開始，把 $u$ 先圖成白色，再把其周圍的點圖成黑色，然後
把距離 $2$ 的點都塗成白色…依此類推，最後再檢查是不是每一個邊的兩端都不同
色即可。

另一個做法是用{\bf 併查集}，對每一個點 $u$ 都建兩個對應的點，$u_0, u_1$。可以把
$u_0$ 想做是「你的顏色」，$u_1$ 則是「非你的顏色」。對於每一條邊 $(u, v)$，
我們就把 $(u_0, v_1), (u_1 v_0)$ 做併查集的合併，意思就是「$u$ 的顏色是非 $v$ 的
顏色」，而圖是二分圖的條件即是每個點 $u$ 對應到的兩個新點 $u_0, u_1$ 都在不同的
併查集裡，如以下這個例題。

\SampleProblem[TIOJ 1672]{分子碰撞實驗}{
  現在有一個未知的序列 $a_1, a_2, \dots, a_n$，依序給你些個資訊 $(s, t, p)$，
  其中 $p \in \{0, 1\}$ 代表 $a_s + a_{s+1} + \dots + a_t \equiv p \pmod{2}$，
  每次你要判斷給你的資訊會不會和已知的資訊有所矛盾，並且如果有矛盾則捨棄之。
}

如果我們令 $b_i = \sum\limits_{0}^{i-1} a_j$，可以發現每次的資訊其實就是在告訴你
$a_{s-1}$ 和 $a_t$ 的奇偶性是相同還是相異。因此我們就修改上述的做法就可以了！
假設 $u = a_{s-1}$ 且 $v = a_t$ 並用剛才的記號，如果他們同奇偶則檢查 $(u_0, v_1)$
是否在不同的集合裡，是的話再合併 $(u_0, v_0), (u_1, v_1)$，反之亦然。

\section{有關圖的問題}
與圖論有關的問題非常多，幾本上不太可能全部掌握，除了多了解一些結論之外，
舉一反三和臨場見招拆招的能力也是很重要的！

\subsection{計算複雜度理論}
「知己知彼、百戰百勝」，要攻克一個題目，我們如果能先知道這個題目有
「多難」會是一大幫助。

那要如何區分問題的難度呢？
通常我們說一個問題是「容易的」表示我們已經知道有一個多項式時間的演算
法可以求出這個問題的答案。比如排序問題，最短路徑問題等等。

但是有一些問題，人們想破頭了都想不出一個多項式時間的演算法可以解出，
比如求一個圖的 Hamilton Path 至今都還沒有一個好的演算法解決他，而且
也沒有辦法證明不存在一個多項式時間的演算法解決他。

百般無奈的人們只好先假設我們有一個更加強大的計算體系了，也就是
{\bf 非確定性圖靈機(Non-deterministic turing machine)}。

在介紹什麼是非確定性圖靈機之前，我們先定義一個合法的問題是什麼。
在這邊我們先只考慮{\bf 判定性問題}。什麼是判定性問題呢？其實就是
答案只有 Yes, No 兩種的問題，比如說「這個圖上是不是存在一個 
Hamilton path 呢？」或是「這個圖是不是一個平面圖？」等等。
至於「從 $u$ 到 $v$ 的最短路徑長度是多少？」就不是判定性問題了。
但是我們大可以把他轉成「從 $u$ 到 $v$ 的最短路徑長度是否小於 $k$？」
這個判定性問題，然後用比如說二分搜的方法解出原本的問題。

而非確定性圖靈機強大的地方就在於，
有別於我們電腦等等的{\bf 確定性圖靈機}的計算體系，在進行搜索時有
時後我們要面臨抉擇。比如說在找一個圖的 Hamilton path 時，我們不知道
起點應該是 $v_1, v_2, \dots$ 裡的哪一個，於是只好一個個試過一遍。
非確定性圖靈機在面臨這種情況時，如果答案是「有解存在」的，他一定會
{\bf 很幸運的選到一個最好的選擇}。

於是我們把所有用確定性圖靈機可以在多項式時間內解出的題目的集合稱作
$\P$，把所有用確定性圖靈機可以在多項式時間內解出的題目的集合就稱作
$\NP$。%
\footnote{所以 $\NP$ 並不是 Non-Polynomial 的縮寫，而是
  Non-deterministic Polynomial 的縮寫。}
在經過一番推敲後我們發現{\bf 一個判定性問題是 $\NP$ 問題若且唯若如果
答案是 Yes，他的一個解 可以在多項式時間被一個內被一個確定性圖靈機驗證}。
比如說 Hamilton Path 是 $\NP$ 問題，因為今天如果有人宣稱 $P$ 是一個 
Hamiltom Path，那你只要 確認 $P$ 通過所有點恰好一次，
而且每一條邊都存在於原本的圖中即可。

定義了 $\NP$ 後，人們就開始問，$\NP$ 裡最難的問題是什麼呢？我們說一個
問題 $A$ 比 $B$ 難表示 $B$ 可以化簡成 $A$，也就是說{\bf 如果我們要
  解 $B$ 問題，我們可以把 $B$ 在多項式時間內作一些轉化，把他變成 $A$ 問
  題。} 比如我們可以證明找一個 Hamilton Cycle 比找 Hamilton Path 還難，
因為如果要找 Hamilton Path，我們可以再原圖多加一個點 $v$ ，然後把 $v$ 
建邊連到所有點。這樣原圖的一個 Hamilton Path 一定可以頭尾用 $v$ 串起來
變成 Hamilton Cycle。而在新的圖如果找到了一個 Hamilton Cycle，只要把
Cycle 中的 $v$ 去掉，就是原本 Hamilton Path 的解了。

也就是說，如果你會解 Hamilton Cycle，那你一定也能解 Hamilton Path。因此
$\NP$ 裡「最難」的問題就代表{\bf 如果你會解這個問題，那所有 $\NP$ 問題都可
  以在多項式時間化簡為這個問題。}不過「最難」的問題真的存在嗎？有的！其實
以經有許多問題被證明是「最難」的 $\NP$ 問題了，如 3-SAT、最大團還
有剛剛說的 Hamilton Path 等都是！我們把這些問題叫作 $\NPC$ ($\NP$-complete)
問題。

而如果我們有一天找到了一個可以在多項式時間內解出某一個 $\NPC$ 問題的演算法，
那不得了了，因為 $\NPC$ 已經是 $\NP$ 裡最難的問題了，所有 $\NP$ 問題都可以
在多項式時間內解出！

很遺憾的是這些 $\NPC$ 問題我們到目前為止都找不到一個多項式時間的演算法，
也沒有辦法證明這樣的演算法不存在！

\subsubsection{這和競賽解題有何關係？}
有的！這往往可以幫助你往正確的方向思考。在解題的過程中我們往往會把題目做一些
變換，轉成其他的題目來解。而如果你發現你轉成了一個 $\NPC$ 問題，除非測資範圍
很小，否則通常表示你一定有什麼題目的性質沒有用到，要從新思考思路！比如前面說
的「平面圖最大團」問題，一般圖的最大團問題是 $\NPC$，因此關鍵一定在平面圖的
性質上！

接下來我們就討論一些圖上常見的問題！

\subsection{2-SAT}
\SampleProblem{2-SAT}{
  給你一個關於變數 $x_1, x_2, \dots, x_n$ 且形式如下的布林代數式
  \[ (y_1 \lor y_2) \land (y_3 \lor y_4) \land \dots \land (y_{2m-1} \lor y_{2m}) \]
  其中 $y_1, y_2, \dots, y_{2m}$ 都是某個 $x_i$ 或是 $\lnot x_i$。也就是每個括號裡都
  恰有兩個變數 \texttt{or} 起來後再全部 \texttt{and} 起來。
  問你是否可以給每一個變數 $x_i$ 一個 \texttt{true} 或是 \texttt{false} 
  值使得原本的布林代數式的結果為 \texttt{true}？
}
這個問題有一個很 well known 的解法，對於每個刮號，假設是 $(x_3 \lor \lnot x_4)$
好了，代表不是 $x_3 = \texttt{true}$，就是 $x_4 = \texttt{false}$。也就是
\begin{itemize}
  \item 如果 $x_3 = \texttt{false}$，那必定有 $x_4 = \texttt{false}$，用邏輯的語言
    寫就是 $\lnot x_3 \rightarrow \lnot x_4$。
  \item 如果 $x_4 = \texttt{true}$，那必定有 $x_3 = \texttt{true}$，用邏輯的語言
    寫就是 $x_3 \rightarrow x_4$。
\end{itemize}
不知道大家有沒有感覺和二分圖判定的時候有點像！只是現在的關係是單向的而已，如上述例子，
$x_3 \rightarrow x_4$，但沒有強迫 $x_4 \to x_3$。

因此解法就是把每一個變數看成是兩個點 $x_i, \lnot x_i$，
再如上面的例子所示把所有關係都建一個有向邊出來，
基本上 $(x_i, x_j), (\lnot x_i, \lnot x_j)$
的建法也類似，讀者可以自己推敲，只有 $(x_i, x_i)$ 這種兩個變數相同比較特別，
想一下後可以知道需要把 $\lnot x_i \to x_i$。
\footnote{用邏輯的解釋，因 $a \to b \equiv \lnot a \lor b$，
  $\lnot x_i \to x_i \equiv (\lnot \lnot x_i) \lor x_i \equiv x_i$
}
類似的 $(\lnot x_i, \lnot x_i)$ 就建 $x_i \to \lnot x_i$。

最後可以發現如果在圖上 $u$ 可以走到 $v$，表示如果「選了」$u$ 就一定要選 $v$，
因此可以想像有解的條件就是對於所有 $x_i, \lnot x_i$，要嘛 $u$ 不能走到 $v$，
要嘛 $v$ 不能走到 $u$，用圖論的說法就是{\bf $x_i, \lnot x_i$ 不能在同一個強連
  通元件！}用 Tarjan 等等的演算法即可以在 $\ord{V+E}$ 的時間內做到。
%
\SampleProblem{以前看過的題目}{給你一個 $R \times C$ 的方格，你有一種特殊的炮彈可以炸一排或一列，
  不過同一排或一列最多只能炸一次。每一格除了可能是空地外，還有可能是
  \begin{description}[leftmargin=!, labelwidth=\widthof{一一一一}]
    \item[敵方要塞] 你必須炸兩次才能消滅他。
    \item[敵方軍團] 你必須炸一次以上才能消滅。
    \item[住宅區] 為了必免無辜的人受害，最多只能炸一次。
    \item[醫院] 這個不用說，當然是炸都不能炸。
  \end{description}
  問你每一排及每一列該選擇炸或是不炸，才能使每一格都符合上述的需求？
}
我們可以用布林變數 $x_i$ 表示第 $i$ 排要炸還是不炸，用 $y_i$ 表示第
$j$ 排要炸與否，那這些規定其實就是
  \begin{description}[leftmargin=!, labelwidth=\widthof{一一一一}]
    \item[敵方要塞] $x_i \land y_j \equiv (x_i \lor x_i) \land (y_j \lor y_j)$
    \item[敵方軍團] $x_i \lor y_j$
    \item[住宅區] $\lnot x_i \lor \lnot y_j$
    \item[醫院] $\lnot x_i \land \lnot y_j \equiv 
      (\lnot x_i \lor \lnot x_i) \land (\lnot y_j \lor \lnot y_j)$
  \end{description}
  轉成 2-SAT 解即可！

\subsubsection{3-SAT}
很不幸的 3-SAT 問題，也就是每個刮號可能有三個變數，雖然好像只差一點
卻是個 $\NPC$ 問題。不過並不是 $\NPC$ 問題
就不值得研究或是優化，有好的搜索方法還是會差很多！現在有些 SAT-solver 在一般沒有設計過的
測資 (如電路等等) 似乎跑到 $10^4$ 個變數都不是問題，好像也是目前在解如電路等價等等
一個很不錯的解法。

\subsection{著色問題}
\subsubsection{點著色}
點著色就是要把圖上的點都塗上顏色，使得相鄰的點都要不同色，並要求用的顏色越少越好。
如果最少用 $k$ 個顏色就足夠了，我們就稱這個圖的著色數為 $k$。
點著色是 $\NPC$ 問題，但是在特殊的圖可能會有特殊的方法。比如大家都熟悉的四色定理

\begin{theorem}[四色定理]
  任意一個平面圖一定可以 $4$ 著色。
\end{theorem}

我們來看一個例題。
\SampleProblem[NERC 2010-2011 pK]{K Graph Oddity}{
  給你一個連通圖 $G$ 滿足 $G$ 有奇數個點，且存在一個奇數 $k$ 使得所有點的度數都
  不超過 $k$。請你把這張圖點 $k$ 著色。
}

其實畫一畫會發現，因為度數最高是 $k$，要把一個圖 $k$ 著色其實非常容易。如果
一個點的度數小於 $k$，也就是最多 $k-1$，那我們跟本不用考慮這個點，等其它點都
塗色了以後，再找一個顏色不在其 $k-1$ 個鄰居中就可以了。

那會不會所有點的 degree 都是 $k$ 呢？不會！否則所有點的度數合是 $k\abs{V}$，這個
等於 $2 \abs{E}$，但 $k, \abs{V}$ 都是奇數，乘出來居然是偶數，矛盾！因此一定有一個
點的度數不超過 $k-1$，那因為這個點更本不需考慮，甘脆把他拔掉吧！而又因為這個點
連通，所以拔掉這個點之後，一定又有一個點的度數變少了，也就是不超過 $k-1$。
一路做下去，所有的點都被我們拔掉了！

那題目就很簡單了，把最後一個拔掉的點塗隨便一個顏色，再把倒數第二個點塗上任一個合法
的顏色…一路做回來，我們上面說明了因為每一次的 degree 都不超過 $k-1$，一定能找到一個
合法的顏色塗！

\subsubsection{邊著色}
類似地，邊著色就是要把圖上的邊都塗上顏色，使得任一個點連出去的所有邊都不同色。
邊著色仍然是一個 $\NPC$ 問題！但有一個很神奇的結論。

\begin{theorem}[Vizing's theorem]
  任意一個簡單圖的邊著色數一定是 $d, d+1$ 中的一個，\\
  其中 $d = \max\limits_{v \in V} \deg(v)$。
\end{theorem}

顯然邊著色數至少要 $d$，但 $d+1$ 一定可以著色就沒有那麼顯然了。
Vizing's theorem 的證明中就給了一個 $d+1$ 著色的演算法，但是滿
複雜的，有興趣可以到 Wiki 上看看。

\subsection{歐拉路徑/回路}
給你一張圖，一個歐拉路徑(Euler path)是一條連續的路徑(點可重複)恰好經過所有的邊。
如果終點恰好回到起點，就稱作是一個歐拉回路。

一筆劃問題就是要問圖上存不存在一條歐拉回路。觀察一下可以發現一個路徑
$P = (v_1, v_2, \dots, v_n)$，除了起點和終點以外，每個點都會從一個邊
進去，再從另一條邊出來，總共會「吃掉」這個點 $2$ 個度數。但因點可能
重複出現在路徑 $P$ 上，因此我們可以知道除了起點/終點外，每個點的度數
都要是偶數！事實上對於連通圖，這不僅是必要條件，還是充分條件。

\begin{theorem}
  定義一個{\bf 奇點}是度數為奇數的點。如果圖連通，有
  \begin{itemize}
    \item 一個無向圖有歐拉路徑的條件是其奇點的個數是 $0$ 或 $2$。
    \item 一個無向圖有歐拉迴路的條件是其奇點的個數是 $0$。
    \item 一個有向圖有歐拉路徑的條件是所有點都滿足 $\deg^+(v) = \deg^-(v)$，
      或是除此之外有一個點滿足 $\deg^+(v) = \deg^-(v) + 1$，另一個滿足
      $\deg^+(v) = \deg^-(v) - 1$。
    \item 一個有向圖有歐拉迴路的條件是所有點都滿足 $\deg^+(v) = \deg^-(v)$，
  \end{itemize}
\end{theorem}


\SampleProblem{構造字串}{ 
  問你存不存在一個字串 $S$ 使得子字串 \texttt{`}$ab$\texttt{'} 恰好出現
  過 $c_{a, b}$ 次，其中 $a, b \in \texttt{`}0123456789\texttt{'}$。

  如 $c_{0, 0} = 2, c_{0, 1} = 1, c_{1, 1} = 1, c_{1, 0}=2$，有字串
  \texttt{`1100010'}。
}

如果把字串，如 \texttt{`13413'} 想像做從 $v_1 \to v_3 \to v_4 \to v_1 \to v_3$ 的
一條路徑，其實原本的題目就是要問你有沒有一條歐拉路徑，計算每一個點的度數即可。

\subsubsection{Hamiltonian path}
一個 Hamiltonian path 是一個簡單路徑通過所有的點恰好一次。
雖然看起來跟 Euler path 很像，但卻是一個 $\NPC$ 問題。通常
的做法是用狀態壓縮 DP ，複雜度是 $\ord{2^V V^2}$。


\subsection{匹配問題}
一個圖的匹配是一個邊集 $E'$，滿足 $E' \subseteq E$ 且每個在圖上的點至多只跟
$E'$ 裡面的一條邊相鄰。一個最大匹配就是 $\abs{E'}$ 最大的一個匹配。
\subsubsection{二分圖上的匹配問題}
二分圖上的最大匹配可以直接轉成最大流問題求解
\footnote{可以參考「最大流」那一章}。我們這邊用另一種看法來看。
首先我們定義何謂交錯路徑。
\begin{theorem}[定義]
  一個{\bf 交錯路徑}是一個路徑 $P = (x_1, y_1, x_2, y_2, \dots, x_n, y_n)$，滿足
  \begin{itemize}
    \item 路徑上的每一條邊都在原圖的邊上。
    \item $x_1, y_n$ 都還沒有被匹配。
    \item $(y_k, x_{k+1})$ 都是已經在匹配中的邊。
    \item $(x_k, y_{k})$ 都是還沒有在匹配中的邊。
  \end{itemize}
  找到一條交錯路徑後，把 $(y_k, x_{k+1})$ 共 $n-1$ 個從匹配中移除，
  並把 $(x_k, y_k)$ 加進匹配中，就是一個大小多 $1$ 的新匹配。
\end{theorem}
可以證明一個匹配是最大匹配的條件就是圖上已經不存在交錯路徑，因此我們可以
不斷的建一棵{\bf 交錯樹}，找交錯路徑增加匹配大小，
直到不存在交錯路徑為止。詳細的證明和方法用
flow 的角度來看非常清礎，我們就不在細講。

\subsubsection{一般圖上的匹配問題}
和二分圖相似，不斷的找交錯路徑擴充。不過不同的是二分圖的交錯路徑 \\
$P = (x_1, y_1, x_2, y_2, \dots, x_n, y_n)$ 剛好有 
$x_i \in X, y_i \in Y$，其中 $X, Y$ 是二分圖的一個二分子集(也就是
$X, Y$ 各自裡面都沒有邊)。一般圖就沒有這種好事了，會造成交錯樹沒有那麼
好建，會有{\bf 花(Blossom)}的存在。

這時候就要修改演算法成{\bf 縮花演算法(Blossom Algorithm)}，不過縮花演算法
蠻難寫的，最好是準備一份放在 Codebook 
\footnote{或許有人不知道，ACM-ICPC 比賽每個隊伍都可以帶約 25 頁單面的 code。}
裡。

當點數如果不大，可以直接用 $\ord{2^V V^2}$ 狀態壓縮 DP 來解。

\subsubsection{帶權匹配問題}
有時後邊上會有權重，你要找一組邊權總合最大的匹配。

在二分圖可以直接轉成 Cost-flow 來做，也有從 Dual problem 下手的演算法如
Hungarian algorithm 。

在一般圖上也有多項式時間的演算法，不過出名的難寫。有一種其妙的假解是
基於以下觀察
\begin{theorem}[定義]
  一個最大帶權匹配中的負環定義為一個交錯環\\
  $P = (x_1, y_1, x_2, y_2, \dots, x_n, y_n, x_1)$，滿足
  \begin{itemize}
    \item $(y_k, x_{k+1}) \; \forall k$ 和 $(y_n, x_1)$ 都是已經在匹配中的邊，
      把這些邊的權重和叫作 $C_1$。
    \item $(x_k, y_{k})$ 都是還沒有在匹配中的邊，
      把這些邊的權重和叫作 $C_2$。
    \item $C_2 > C_1$
  \end{itemize}
  找到一個負環後，把上面 $n$ 個已匹配邊從匹配中移除，
  其它 $n$ 個加到匹配裡，那新的匹配的權重和更大。
\end{theorem}
發揮創意不斷的找負環直到沒有，就是一個最大帶權匹配了。

\subsubsection{一些相關的問題}
我們這邊列了一些相關的問題。
\begin{description}[leftmargin=*]
  \item[最大獨立點集] 一個最大的點集 $V'$ 使得裡面的點都不相鄰。其大小記做 $I(G)$。
  \item[最大匹配數] 前面定義過了。其大小記做 $M(G)$。
  \item[最小點覆蓋] 最小的一個點集，使得所有的邊都至少與點集裡的
    一個點相鄰。\\其大小記做 $C_v(G)$。
  \item[最小邊覆蓋] 最小的一個邊集，使得所有的點都至少與邊集裡的
    一個邊相鄰。\\其大小記做 $C_e(G)$。
\end{description}
這些問題是很有相關性的，有以下定理：
\begin{theorem}
  對於連通圖，有
  \begin{itemize}
      \item $I(G) + C_v(G) = \abs{V}$. 
        \refstepcounter{equation} \hfill{}(\theequation)\label{eq:m1}
      \item $M(G) + C_e(G) = \abs{V}$.
        \refstepcounter{equation} \hfill{}(\theequation)\label{eq:m2}
      \item 對連通二分圖，有 $M(G) = C_v(G), I(G) = C_e(G)$.
        \refstepcounter{equation} \hfill{}(\theequation)\label{eq:m3}
  \end{itemize}
\end{theorem}

\begin{proof}
  對 \eqref{eq:m1} 我們證明一個獨立點集 $U$ 的補集 $U^c$ 一定是一個點覆蓋。對於所有邊 $(u, v)$，
  可知 $u, v$ 至少有一個不在 $U$，也就是在 $U^c$，因此 $U^c$ 覆蓋所有邊。
  這也同時證明了一個點覆蓋 $U$ 的補集 $U^c$ 一定是一個獨立點集。因此 $I(G) + C_v(G) = \abs{V}$。

  對 \eqref{eq:m2} ，我們先證明 $C_e(G) \leq \abs{V} - M(G)$。先找一個最大匹配 $M$，
  注意到 $M$ 恰好蓋住了 $2\abs{M} = 2 M(G)$ 個點，又因圖連通，可在找 $\abs{V} - 2 M(G)$
  個邊就把所有點都蓋住了，因此 $C_e(G) \leq \abs{V} - 2 M(G) + M(G) = \abs{V} - M(G)$。

  我們再證明 $C_e(G) \geq \abs{V} - M(G)$，也就是 $M(G) \geq \abs{V} - C_e(G)$。
  先找一個最小邊覆蓋。這些邊(加上端點)會形成許多連通塊，而對於任一個連通塊，不會有環
  ，否則隨便拔掉一條環上的邊仍可覆蓋所有點，也就是每個連通塊都是一棵樹。而每一個連
  通塊任選一條邊，這些選出來的邊都不相鄰，所以是一個匹配。假設連通塊分別為
  $S_1, S_2, \dots, S_n$，有 $V(S_1) = E(S_1) + 1$。因此
  \[ M(G) \geq n = \sum V(S_i) - E(S_i) = \sum V(S_i) - \sum E(S_i) = \abs{V} - C_e(G) \]
  
  最後證 \eqref{eq:m3}。首先對於一個匹配 $M$ 中的任一個邊，點覆蓋一定要蓋住其中一點，
  因此 $C_v(G) \geq M(G)$。 現在如果有一個圖 $G$ 滿足 $C_v(G) > M(G)$，找 $\abs{V}, \abs{E}$
  最小的一個反例。容易證明 $G$ 不是一條路徑或是一個環，因此有一個點 $u$ 的度數至少是 $3$。
  假設 $u$ 和 $v_1, v_2, v_3$ 相鄰，如果 $G_1 = G \setminus v_1$ 的最大匹配數 $M(G_1) < M(G)$，
  則因 $C_v(G_1)$ 至少是 $C_v(G) - 1$，有 $M(G_1) \leq M(G) - 1 < C_v(G_1)$，與反例的最小性
  矛盾。因此存在一個最大匹配 $M$ 使得 $v_1 \notin M$。而 $(u, v_2), (u, v_3)$ 至少有一個
  不在 $M$ 中，假設是 $e = (u, v_2)$，那考慮 $G_2 = G \setminus e$ 的最小覆蓋 $C$，由反例的最小
  性有 $M(G) = M(G_2) = C_v(G_2)$，且因為對於一個匹配 $M$ 中的任一個邊，點覆蓋一定要蓋住其中一點，
  $v_2 \notin C$，從而 $u \in C$ 所以 $C$ 也是 $G$ 的覆蓋，$M(G) = C_v(G)$，矛盾。因此
  \eqref{eq:m3} 成立。
\end{proof}

\eqref{eq:m3} 的證明其實沒有給出一個構造點覆蓋的方法，實際的構造方法有些複雜，可以
參考 Wiki。

\subsection{其它的問題}
前面講了那麼多種圖論的問題，可以發現圖論問題真的是非常豐富！
在程式競賽中更可能會出現其它奇奇怪怪的問題，這時候就只能見招拆招了！
如下面這一題

\SampleProblem{怪圖怪題}{ 
  一個 Union-Join graph 定義為
  \begin{itemize}
    \item 一個點 $v$ 是一個 Union-Join graph.
    \item 如果 $G, H$ 都是 Union-Join graph，那他們的 Union 
      \[ G \cup H = (V(G) \cup V(H), E(G) \cup E(H)), \]
      也是 Union-Join graph.
    \item 如果 $G, H$ 都是 Union-Join graph，那他們的 Join 
      \[ G \oplus H = (V(G) \cup V(H), E(G) \cup E(H) \cup E'), \]
      其中$E' = \{(u, v) : \forall u \in G, v \in H\}$
      也是 Union-Join graph.
  \end{itemize}

  現在給你一個 Union-Join graph，你要把每一個點填上一個數字 $c(v)$，使得
  如果兩個點 $u, v$ 的數字相同，那任何 $u \leadsto v$ 的路徑上，
  都要有一個點 $w$ 使得 $c(w) < c(u)$。問你至少要用幾個不同的數字。
}

乍看之下題目無比複雜，但越複雜的題目可能反而是越簡單的題目！首先觀察到這個
圖是{\bf 被遞迴}的定義出來的，因此我們不妨就猜測，假設最少需要的數字數量是
$\tau(G)$，如果 $G = G_1 \cup G_2$，那 $\tau(G) = \tau_\cup(G_1, G_2)$，
且如果 $G = G_1 \oplus G_2$，那 $\tau(G) = \tau_\oplus(G_1, G_2)$。
我們只需要求出 $\tau_\cup, \tau_\oplus$ 這兩個函數是怎麼樣的函數就可以了。

顯然 $\tau_\cup(G_1, G_2) = \max(\tau(G_1), \tau(G_2))$，因為 Union 其實就只
是把兩張圖擺在一起而已，彼此互不影響。至於 $\tau_\oplus$ 比較複雜，觀察後可以
發現
\begin{enumerate}
  \item  兩邊的點不能有相同的數字，不然 union 就把兩個相同的數字連起來了。
  \item  Union後只有一邊裡的點可以有相同的數字，另一邊內的點一定要全不相同。
          不然如果 $G_1$ 中 $u_1, u_2$ 相同， $G_2$ 中 $v_1, v_2$ 相同，
          如果 $c(u_1) < c(v_1)$，union 後會有路徑
        $u_1 \to v_1 \to u_2$ 不符合要求，反之亦然。
\end{enumerate}
因此由上面討論我們猜想 $\tau_\oplus(G_1, G_2) = \min(\tau(G_1)+\abs{V(G_2)}, 
\tau(G_2)+\abs{V(G_1)})$。
由 1. 2. 知道這是下界，而一邊的點 (假設是 $G_1$) 選 $1, 2, \cdots, \abs{V(G_1)}$，一
邊令 $c(v) = c'(v) + V(G_1)$ 其中 $c'(v)$ 是原先的答案，顯然是一組解，因此這個答案是正確的。

這樣寫好不好呢？其實可以證明這樣的{\bf 期望複雜度}是$\ord{\abs{A}}$。可惜的是，最差的情況可以到$\ord{\abs{A}\abs{B}}$！更糟的是很容易構造出例子，如$A = \mcstr{AAAAA}{AA}, B = \mcstr{AAA}{B}$，這樣雖然$B$從來沒有出現在$A$中，但是每個位置我們都必需匹配到$B$的最後一個字元才能確定匹配失敗！
那要怎麼改進這個演算法呢？著手點有兩個：
\begin{enumerate}
  \item 事前處理：我們剛剛一拿到兩個字串便埋頭苦幹，但如果我們能先對這兩個字串做點觀察、處理，或許能得到一些有用的資訊。
  \item 善用已知的資訊：在匹配的過程中，或許我們也可以得到一些訊息！顯然這個做法並沒有妥善利用！
\end{enumerate}
\section{Hashing}
想想看你要在茫茫人群中找你的同學，通常會怎麼找呢？不外乎是先看衣服顏色，髮形之類的。沒錯！如果我們可以把東西加以分類，便可加速蒐尋速度！但當然，分類也是有技巧的，就像你不會用"正立/倒立走路"或是"指紋圖形"來分類路人，因為前者沒有多少人是用倒立走路的吧，而後者雖然極精確，但也太花時間了！\\
在字串上也是相同的道理，總而言之我們想做的事情是：
\begin{enumerate}
  \item 找到一個分類函數，即是一個$f: \mathbb{S}(\Sigma) \mapsto \mathbb{Z}$，把所有可能的字串打到有界的整數，不妨說$f(s) \in [0, M-1] \; \forall s$吧！
  \item 這個函數最好是均勻分部在$[0, M-1]$上。
  \item 計算這個函數最好不需花太多時間！
\end{enumerate}
\begin{theorem}[定義]
  一個滿足以上條件的函數我們就稱作\emph{Hash function}
\end{theorem}
有了Hash function後有什麼用呢？有的！雖然我們{\bf 無法保證$A \neq B \; \Rightarrow f(A) \neq f(B)$}，因為$f$把有無窮多個元素的字串集合打到有限個整數上，當然會有許多字串被打到同一個整數！但至少我們會知道
\[
  f(A) \neq f(B) \quad \Rightarrow \quad A \neq B
\]
也就是說如果兩個字串的Hash value不一樣，那我們連匹配都不需要了，他們鐵定不相等！
至於Hash function要怎麼找呢？一個常用的方法如下
\begin{theorem}[Rabin-Karp rolling hash function]
  給定$p, q$，令
  \begin{align*}
    f(A) &= a_0 p^{n-1} + a_1 p^{n-2} + \cdots + a_{n-2} p + a_{n-1} \mod{q}\\
         &= \sum_{0}^{n-1} a_i p^{n-i-1} \mod{q} \numbereqn \label{rol}
  \end{align*}
\end{theorem}
看起來很複雜，其實就是字串$A$在$p$進位制代表的值模$q$而已！那這個函數有符合我們的需求嗎？首先他把每個字串打到$[0, q-1]$，可以想成他把所有字串分成$q$類。另外數學家跟我們說，如果$p,q$取兩個不同的質數，通常結果會不錯，非常均勻\footnote{可以參考習題1-8}！另外計算這個函數只需要$\ord{|A|}$，並且他還有一個很好的性質！
\begin{theorem}[Sliding Window]
  假設$f$由\eqref{rol}給出，則
  \begin{equation}
    \label{sld1}
    f(A) \equiv f(A[0, n-2]) p + a_{n-1} \pmod{q}
  \end{equation}
  並且
  \begin{equation}
    \label{sld2}
    f(A[i, j]) \equiv f(A[0, j]) - p^{j-i+1} f(A[0, i-1]) \pmod{q}
  \end{equation}
\end{theorem}
這些都可以由\eqref{rol}計算得出。\eqref{sld1}告訴了我們計算字串$A$所有前綴的hash value可以在$\ord{\abs{A}}$的時間用遞迴求出！仔細看\eqref{sld2}可以發現如果知道了$A$所有前綴的hash value，任何$A$的子字串的hash value都可以在$\ord{1}$的時間計算出來\footnote{真的嗎？$p^{j-i+1}$怎麼辦？}！ \\
回到我們字串匹配的問題，相信大家都看出來了，我們只需要事先算出$A$所有前綴的hash value和$f(B)$，再枚舉$A$所有長度為$\abs{B}$的子字串(差不多$\ord{A}$個)，最後計算這些子字串的hash value是不是等於$f(B)$，總共只需要$\ord{N}$…
等等！回想我們剛剛說的：我們知道$f(A) \neq f(B) \Rightarrow A \neq B$，但卻無法保證$f(A) = f(B) \Rightarrow A = B$啊？有人可能會想說："相等時重新檢查一次"，但如果$A = \mcstr{AAA}{AAA}, B = \mcstr{AA}{AA}$，完蛋了！又退化成$\ord{\abs{A} \abs{B}}$了！ \\
那怎麼辦呢？答案是：把$q$取大一點，然後就假設$f(A) = f(B)$的機率很小，不會發生！事實上如果$f$是均勻的，那$f(A) = k$的機率差不多是$1/q$！只要$q$取夠大，比如一個\texttt{long long}的質數，差不多$10^{15}$，那麼兩個不同的字串{\bf 碰撞}的機率是$10^{-15}$，是一個人被閃電打到兩次的機率\footnote{機率一次差不多是$8 \times 10^{-7}$}，不太可能啦！

\section{KMP}
剛剛說的Hashing method畢竟還是一個機率演算法，而且模運算是很花時間的！因此這邊要講一個很厲害的演算法，Knuth–Morris–Pratt algorithm！ \\
我們先回到一開始naive matching失敗的例子，$A = \str{aabaabaac}, B = \str{aabaac}$，我們第一次的匹配如下，在$5$的位置匹配失敗。

    \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}
        \node at (-0.5, 1.3) {$ i = $};
        \node at (-0.5, .5) {$ A = $};
        \foreach \c [count=\x from 0] in {a,a,b,a,a,b,?,?} {
          \ifthenelse{\x = 5}
          { \draw[fill=gray!80] (\x, 0) rectangle ++(1, 1) }
          { 
            \ifthenelse{\x > 5}
            { \draw[fill=gray!0] (\x, 0) rectangle ++(1, 1) }
            { \draw[fill=gray!30] (\x, 0) rectangle ++(1, 1) }
          }
          node[midway] {\large \c} 
          node[midway, yshift=0.8cm] {\x};
        }
        \node at (8.5, 0.5) {$\cdots$} ;

        \node at (-0.5, -.8) {$ B = $};
        \node at (-0.5, -1.6) {$ j = $};
        \foreach \c [count=\x from 0] in {a,a,b,a,a,c} {
          \ifthenelse{\x = 5}
          { \draw[fill=gray!80] (\x, -1.3) rectangle ++(1, 1) }
          { \draw[fill=gray!30] (\x, -1.3) rectangle ++(1, 1) }
            node[midway] {\large \c} 
            node[midway, yshift=-0.8cm] {\x};
        }

      \end{tikzpicture}
    \end{center}
    \caption{}
    \label{fig:}
    \end{figure}

那些$A$還沒被匹配過的地方我們用? 表示。現在如果我們用最原始的方法，我們必須將$B$右移一格繼續匹配，重新來過。但仔細觀察就會發現

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node at (-0.5, 1.3) {$ i = $};
    \node at (-0.5, .5) {$ A = $};
    \foreach \c [count=\x from 0] in {a,a,b,a,a,b,?,?} {
      \ifthenelse{\x = 5}
      { \draw[fill=gray!30] (\x, 0) rectangle ++(1, 1) }
      { 
        \ifthenelse{\x > 5}
        { \draw[fill=gray!0] (\x, 0) rectangle ++(1, 1) }
        { \draw[fill=gray!30] (\x, 0) rectangle ++(1, 1) }
      }
      node[midway] {\large \c} 
      node[midway, yshift=0.8cm] {\x};
    }
    \node at (8.5, 0.5) {$\cdots$} ;

    \foreach \c [count=\x from 0] in {a,a,b,a,a,c} {
      \ifthenelse{\x = 0}
      { \draw[fill=gray!30] (\x, -1.3) ++ (1, 0) rectangle ++(1, 1) }
      { \ifthenelse{\x = 1} 
        { \draw[fill=gray!80] (\x, -1.3) ++ (1, 0) rectangle ++(1, 1) }
        { \draw[fill=gray!0] (\x, -1.3) ++ (1, 0) rectangle ++(1, 1) }
      }
        node[midway] {\large \c} ;
    }

    \foreach \c [count=\x from 0] in {a,a,b,a,a,c} {
      \ifthenelse{\x = -1}
      { \draw[fill=gray!30] (\x, -2.5) ++ (2, 0) rectangle ++(1, 1) }
      { \ifthenelse{\x = 0} 
        { \draw[fill=gray!80] (\x, -2.5) ++ (2, 0) rectangle ++(1, 1) }
        { \draw[fill=gray!0] (\x, -2.5) ++ (2, 0) rectangle ++(1, 1) }
      }
        node[midway] {\large \c} ;
    }

    \foreach \c [count=\x from 0] in {a,a,b,a,a,c} {
      \ifthenelse{\x < 3}
      { \draw[fill=gray!30] (\x, -3.7) ++ (3, 0) rectangle ++(1, 1) }
      { \ifthenelse{\x = 3} 
        { \draw[fill=gray!50] (\x, -3.7) ++ (3, 0) rectangle ++(1, 1) }
        { \draw[fill=gray!0] (\x, -3.7) ++ (3, 0) rectangle ++(1, 1) }
      }
        node[midway] {\large \c} ;
    }

  \end{tikzpicture}
\caption{}
\label{fig:}
\end{figure}

右移$1, 2$格分別在$1, 0$的位置就匹配失敗了。注意到這兩個位置都對應到$A[2]$，而$A[2]$是我們早就匹配過的！也就是說這個"失敗"是我們應該要知道的。更甚者，這整件事情只跟$B$本身有關！因為我們早以確認過$A[0, 4] = B[0, 4]$。換句話說，對於一個字串$B$，不論$A$是多少，我們早就可以知道某些$(j, s)$，代表"如果我們在$B[j+1]$的位置匹配失敗後，往前$s$格繼續匹配"這件事情，是完全不必要的！\\
那到底在$B[j+1]$匹配失敗時，我們該往右移幾格呢？根據我們上面的討論，如果我們已經匹配了$A[i, i+j] = B[0, j]$，現在將$B$右移$s$格，那麼至少$A[i+s, i+j] = B[0, j-s]$，也就是
\[ B[0, j-s] = A[i+s, i+j] = B[s, j] \]
因此我們應該要找第一個(最小的)$s$滿足上式，也就是最大的$j-s$。這就是我們要定義的KMP裡一個非常重要的函數─失敗函數$\fail(j)$。

\begin{theorem}[定義(Fail function)]
  對於一個字串$B = b_0 b_1 \cdots b_{m-1}$，我們定義
  \[
    \fail_B(i) = 
    \begin{dcases}
      \max \{ k: P_B(k) = B[0, k] = B[i-k, i] \} & \text{if } i \neq 0 \text{ and at least a $k$ exists}\\
      -1 & \text{else}\\
    \end{dcases}
  \]
  $\fail(i)+1$也稱作在第$i$個位置的\emph{共同前後綴}長度
\end{theorem}

由上面的推論，我們總結$\fail(j)$的一個非常重要的性質：{\bf $\fail_{B}(j)$告訴我們在拿$B$去匹配$A$的過程中，如果$B[0, j]$已經匹配成功，但在第$j+1$個位置匹配失敗了，應該要把$B$的第$\fail(j)$個字元對齊原本$B[j]$的位置繼續匹配}！舉個例子，容易知道如果$B = \str{aabaabd}$，則 $ \{\fail(j)\} = \{-1, 0, -1, 0, 1, 2, -1\}$，假設我們已經匹配$B[0,4]$，但在第$5$個字元出問題了，
\begin{monobox}
01234567
A = aabaaa?????
    |||||*        Matching failed at position 5
B = aabaabd         
       ||*        F(4) = 1, Matching failed at position 2
       aabaabd
        |*        F(1) = 0
        aabaabd
\end{monobox}
這樣我們一次可能往前一大步，而不用每次位移一格重新匹配了！\\
現在只剩一個問題了，要怎麼求失敗函數呢？其實很簡單，假設我們已經求出了\\
$\fail(i), \forall 0 \leq i \leq n$，現在要求$\fail(n+1)$，根據定義相當於要求最大的$k = k'+1$使$B[0, k] = B[n+1-k, n+1]$。而
\[
  B[0, k] = B[n+1-k, n+1] \; \Leftrightarrow \; B[0, k'] = B[n-k', n] \land B[k'+1] = B[n+1]
\]
由失敗函數的定義我們知道$k'$最大只能是$\fail(n)$，如果此時$B[\fail(n)+1] = B[n+1]$我們立刻便知道$\fail(n+1) = \fail(n) + 1$。但如果不是怎麼辦？難道必需 $k' = \fail(n)-1 , \fail(n)-2\cdots, 0$ 一直試下去嗎？不要忘記我們已經算出所有 $n$ 以下的 $\fail(i)$ 了，而 $\fail(j)$ 告訴我們在$B$匹配$A$的過程中，如果
\[ A[i, i+j] = B[0, j] \; \land \; A[i+j+1] \neq B[j+1] \]
我們應該把$B$的第$\fail(j)$個字元對齊原本$B[j]$的位置繼續匹配，令$A = B, i = n - \fail(n), j = \fail(n) \leq n$，上式變成
\[ B[n - \fail(n), n] = B[0, \fail(n)] \; \land \; B[n+1] \neq B[\fail(n)+1] \]
這不恰恰是我們現在的情況嗎？因此由 $\fail(j) = \fail(\fail(n))$ ，我們便把當前位置($n$)對齊 $B[\fail(\fail(n))]$。也就是下一個要試的$k'$是$\fail(\fail(n))$！如果又失敗，我們便再試$\fail^3(n), \fail^4(n) \cdots$，直到終於成功或是確認沒有$k$存在($\fail(n+1) = -1$)。這正是失敗函數的精髓！他告訴我們一旦失敗該何去何從。\\
這邊附上一個KMP的範例程式碼，並總結一下KMP的性質。

\SourceCode[kmp]{kmp.cc}{4}{31}

\begin{theorem}[定理]
  對於一個字串$B$，有
  \begin{itemize}
    \item $B[0, \fail(i)]$是$B$最長的一個前綴使得$B[0, \fail(i)] = B[i - \fail(i), i]$但$\fail(i) \neq i$
    \item 令$\fail^k(i) = \overbrace{f \circ f \circ \cdots \circ f}^{k} (i)$，則：
      \begin{itemize}
        \item $\exists n, \; \fail^n(i) = -1$
        \item $ \fail^{k+1}(i) < \fail^{k}(i) \quad \text{if} \quad \fail^k(i) \neq -1 $ \listeqn \label{fail2}
        \item 令$K = \{ i, \fail(i), \fail^2(i) , \cdots , \fail^{n-1}(i), \fail^n(i) = -1\}$，則\\$B[0, k] = B[i-k, i] \; \Leftrightarrow \; k \in K$ \listeqn
      \end{itemize}
    \item $-1 \leq \fail(i+1) \leq \fail(i) + 1$ \listeqn
  \end{itemize}
\end{theorem}

最後我們分析一下KMP的時間複雜度，參考範例程式碼，可以發現不管在計算$\fail$或是在匹配，對於每一次的匹配，當前$B$的匹配位置(current\_pos)會
\begin{enumerate}[(a)]
  \item 被疊代入$\fail$若干次。
  \item 如果匹配成功，便加$1$。
\end{enumerate}
但因為\eqref{fail2}，我們知道每次疊代current\_pos至少會減$1$，並且疊代到$-1$時便會停止，因此(a)中疊代的次數不會超過(b)被執行的次數！而(b)又不會超過字串的長度，所以KMP的時間複雜度是$\ord{\abs{A} + \abs{B}}$，線性！

\section{Aho–Corasick Algorithm*}
  Aho-Corasick Algorithm 可以說是 KMP 的強化板。如果今天我們要在字串$A$上搜尋很多字串$B_1, B_2, \cdots B_n$要怎麼做？當然我們可以做$n$次KMP得到一個$\ord{n\abs{A} + \sum\abs{B}}$的方法，但信不信由你，其實我們可以在$\ord{\abs{A} + \sum \abs{B}}$的時間完成！ \\
%
  KMP在進行字串匹配之前必需要計算失敗函數，與此類似，Aho-Corasick Algorithm要先造出一個AC自動機，聽起來很炫，好像是可以自動幫我們AC題目的機器，其實應該只是Aho-Corasick的縮寫而已啦！ \\

  還記得KMP的Fail function $\fail$嗎？其實我們可以想像Fail function 是一堆指針，告訴我們匹配失敗時要回到哪裡。現在我們要推廣到多個匹配字串呢？首先我們要把所有的匹配字串建成一棵{\bf 字典樹Trie}，
  此時你會發現，匹配的過程其實就是在Trie上面移動！假設我們已經在點 $v$ ，如果下一個字元 $A[i+1]$ 存在於 $v$ 的子節點中，那我們就繼續往下走。
  現在和單字串匹配其時一模一樣！我們現在只需要克服那一個共同的問題即可，當匹配失敗時，也就是 $A[i+1]$ 不在 $v$ 的子節點中，如何避免回到根節點全部重新來過？ 回憶一下 $\fail(j)$ 的定義 
  \[ B[0, \fail(j)] = P_B(\fail(j)) = B[j-\fail(j), j], \quad \text{且 }\fail(j) \text{ 最大}\]
  也就是說$P_B(\fail(j))$要是$B[0, j]$的後綴 \footnote{回憶一下$\fail(i)+1$也是{\bf 最長共同前後綴}長度}
  。那在字典樹上，我們理所當然應該修正為以下的定義

\begin{theorem}[定義]
  對於一個字典樹$T = \{V, E\}$，其中$v_0$為他的根節點，對$v \in V$我們定義
  \[
    \flk(v) = 
    \begin{dcases}
      u & \text{if } P_T(u) \text{ 是 }P_T(v)\text{ 的一個後綴且 }\abs{S_T(u)}\text{最大} \\ 
    v_0 & \text{else}
    \end{dcases}
  \]
\end{theorem}
記得$P_T(v)$ 我們定義成從根節點走到$v$的字串。
這樣與KMP時一樣，我們匹配失敗時就沿著$\flk(v)$往下走，直到可以繼續匹配下去或是回到了根節點了。\\
現在唯一的問題只剩下如何建出$\flk(v)$了。觀察後可發現
\[
  u = \flk(v) \quad \Rightarrow \quad \abs{S_T(u)} < \abs{S_T(v)}
\]
因此我們可以以BFS的順序，逐一建出這個表！
\SourceCode[AC automata]{ACautomata.cpp}{1}{9999}
與KMP相似，匹配時若失敗便往$\flk(v)$走，直到走到根節點或是終於匹配成功為止。

\section{Z Algorithm}
  在計算一個答案時，如果能妥善利用已知的資訊，便可以加速計算所需的時間。而Z Algorithm便是充分的利用這一點。現在我們就來介紹這個名字很帥氣的演算法。
  首先我們定義Z function
\begin{theorem}[定義]
  對於一個字串$A = a_0 a_1 \cdots a_{n-1}$，定義
  \[
    Z_A(i) = \begin{dcases}
      0, \quad \text{if } i = 0 \text{ or } A[i] \neq A[0] \\
      \max \{ k : A[0, k-1] = A[i, i+k-1] \}, \quad \text{else}
    \end{dcases}
  \]
\end{theorem}
看起來和失敗函數$\fail(i)$有點像，但不一樣的是$Z(i)$表示$A$的後綴$S_A(i)$，也就是從$A[i]$開始的字串，可以和$A$自已匹配多長。舉例來說如果$A = \str{abcabc}$，則$Z(3) = 3$。

現在我們需要一個快速求出所有 $Z(i)$ 的方法，假設我們已經知道了 $Z(i) = z$，也就是 $A[0, z-1] = A[i, i+z-1]$。那麼 $Z(i+1), Z(i+2), \cdots , Z(i+z-1)$ 是否會和 $Z(1), Z(2), \cdots, Z(z-1)$ 有關係呢？
事實上Z function有一個很重要的性質是
\begin{theorem}[定理]
  對於一個字串$A = a_0 a_1 \cdots a_{n-1}$，如果$Z(i) = z$，則
  \begin{itemize}
    \item $A[k] = A[i+k], \quad \text{if } \; 0 \leq k < z$.
    \item $A[z] \neq A[i+z]$. \listeqn \label{eq:z-0}
    \item 令$L = i, R = i + z - 1$，現在假設$L \leq j \leq R, j' = j - L$，則：
      \begin{itemize}
        \item 如果$j' + Z(j') < z $，則 $Z(j) = Z(j')$ \listeqn \label{eq:z-1}
        \item 如果$j' + Z(j') > z$， 則 $Z(j) = R - j + 1$ \listeqn \label{eq:z-2}
        \item 如果$j' + Z(j') = z$， 則 $Z(j) \geq R - j + 1 = Z(j')$ \listeqn \label{eq:z-3}
      \end{itemize}
  \end{itemize}
\end{theorem}
重點是\eqref{eq:z-1}, \eqref{eq:z-2}, \eqref{eq:z-3} 這三個case，我們來好好解釋
\begin{enumerate}[label=Case \arabic*.]
  \item $j' + Z(j') < z$
    \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}[scale=0.8, transform shape]
        \draw[line width=0.5mm] 
        (0, 0) -- (7, 0)
        (0, -.3) -- (0, .3)
        (2, -.2) -- (2, .2)
        (3, -.2) -- (3, .2)
        (7, -.3) -- (7, .3)
        (6, -.2) -- (6, .2)
        (9, 0) -- (16, 0)
        (9, -.3) -- (9, .3)
        (16, -.3) -- (16, .3)
        (10, -.2) -- (10, .2)
        (11, -.2) -- (11, .2)
        (12, -.2) -- (12, .2)
        (15, -.2) -- (15, .2)
        ;

        \draw[line width=0.4mm] 
        (2, 1) -- (5, 1)
        (2, .8) -- (2, 1.2)
        (3, .8) -- (3, 1.2)
        (4, .8) -- (4, 1.2)
        (5, .8) -- (5, 1.2)

        (11, 1) -- (14, 1)
        (11, .8) -- (11, 1.2)
        (12, .8) -- (12, 1.2)
        (13, .8) -- (13, 1.2)
        (14, .8) -- (14, 1.2)
        ;
        \draw[latex-]
        (6.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$z-1$};
        \draw[latex-]
        (2.5, 1.5) -- ++(0, 1) node[above, scale=1.2]{$j'$};
        \draw[latex-]
        (4.5, 1.5) -- ++(0, 1) node[above, scale=1.2, xshift=0.3cm]{$j' + Z(j') - 1$};
        \draw[latex-]
        (9.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$L$};
        \draw[latex-]
        (11.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$j$};
        \draw[latex-]
        (15.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$R$};
      \end{tikzpicture}
    \end{center}
    \caption{}
    \label{fig:}
    \end{figure}

    這種情況因為沒有超出以前計算的範圍，所以我們可以直接用之前的結果，$Z(j) = Z(j')$。
  \item $j' + Z(j') > z$

    \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}[scale=0.8, transform shape]
        \draw[line width=0.5mm] 
        (0, 0) -- (7, 0)
        (0, -.3) -- (0, .3)
        (2, -.2) -- (2, .2)
        (3, -.2) -- (3, .2)
        (7, -.3) -- (7, .3)
        (6, -.2) -- (6, .2)

        (10, 0) -- (17, 0)
        (10, -.3) -- (10, .3)
        (17, -.3) -- (17, .3)
        (11, -.2) -- (11, .2)
        (12, -.2) -- (12, .2)
        (13, -.2) -- (13, .2)
        (16, -.2) -- (16, .2)
        ;
        \draw[line width=0.5mm]
        [dashed] (7, 0) -- (8, 0)
        (8, .2) -- (8, -.2)
        ;

        \draw[line width=0.4mm] 
        (2, 1) -- (8, 1)
        (2, .8) -- (2, 1.2)
        (3, .8) -- (3, 1.2)
        (7, .8) -- (7, 1.2)
        (8, .8) -- (8, 1.2)

        (12, 1) -- (17, 1)
        (12, .8) -- (12, 1.2)
        (13, .8) -- (13, 1.2)
        (16, .8) -- (16, 1.2)
        (17, .8) -- (17, 1.2)
        ;

        \draw[line width=0.4mm, dashed]
        (17, 0) -- (18, 0)
        (18, -.2) -- (18, .2)
        ;
        \draw[latex-]
        (6.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$z-1$};
        \draw[latex-]
        (2.5, 1.5) -- ++(0, 1) node[above, scale=1.2]{$j'$};
        \draw[latex-]
        (7.5, 1.5) -- ++(0, 1) node[above, scale=1.2, xshift=0.3cm]{$j' + Z(j') - 1$};
        \draw[latex-]
        (10.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$L$};
        \draw[latex-]
        (12.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$j$};
        \draw[latex-]
        (16.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$R$};
        \draw[latex-latex]
        (7.5, -.5) |- (17.5, -2.4) -- (17.5, -.5);
        \draw[thick]
        (11.8, -2.2) -- (12.2, -2.6)
        (12.2, -2.2) -- (11.8, -2.6)
        ;
      \end{tikzpicture}
    \end{center}
    \caption{}
    \label{fig:}
    \end{figure}

    這個情況由 \eqref{eq:z-0} 我們會知道$A[j' + Z(j') - 1] \neq A[R+1]$，所以從$j$開始最長也只能匹配到$R$了，因此$Z(j) = R - j + 1$。

  \item $j' + Z(j') = z$
    最後一種情況雖然我們無法直接得出$Z(j)$，但我們至少會知道$Z(j) \geq Z(j')$，因此我們繼續從$R$下去匹配就可以了！
\end{enumerate}

仔細分析了之後我們可以知道，除非是第3種Case才需要計算。假設計算 $Z(j)$ 時用到了第3種Case，我們就把 $(L, R)$ 更新為 $(j, j+Z(j)-1)$，可以發現如這樣做$R$值只會一直增加，且增加次數不可能超過字串的長度，並且匹配的次數恰好就是$R$增加的次數，因此求出所有位置的$Z(i)$時間複雜度只需$\ord{N}$。

\SourceCode[Z value]{z-value.cc}{14}{32}

不過這和字串匹配有什麼關係呢？假設我們要拿 $B$ 匹配 $A$ ，只要令 $C = B \phi A$，其中 $\phi$ 是從來沒有在 $A, B$ 間出現過的字元，這樣如果 $A[i, i+k-1] = B, \: k = \abs{B}$ ，必有 $C[k+i+1, 2k+i] = C[0, k-1]$ ， 也就是
$ Z_C(k+i+1) = k $。

除此之外 Z algorithm 還可以解決諸如最長回文子字串等等的問題，方法和這裡類似，就留給讀者思考了。
\section{Suffix Array}
Suffix Array 是解決字串問題中的一把很神秘的武器，乍看之下不知道他的用處何在，其實一大半的問題都可以用他來解決。這麼好用的東西一定要把他學起來！\\

\begin{theorem}[定理]
  對於一個字串$B$的兩個不同的後綴$S_B(i), S_B(j)$，必有$S_B(i) \neq S_B(j)$，即
  \[ 
    S_B(i) < S_B(j) \quad \text{or} \quad S_B(i) > S_B(j)
  \]
\end{theorem}
這是理所當然的，因為後綴兩兩不等長。而後綴數組要做的事就是把他們的順序找出來。後綴的順序在最後會給我們許多非常有用的資訊！

首先我們定義一些東西：
\begin{theorem}[定義]
  對於一個長度為$n$的字串$B$，令$S_B = \{ S_B(0), S_B(1), \cdots S_B(n-1)\}$為所有後綴的集合，定義
  \begin{enumerate}
    \item $\rank(i)$表示後綴$S_B(i)$在$S_B$中是字典序第幾小的(從$0$開始算)。
    \item $\sa(i) = \rank^{-1}(i)$，也就是說第$i$小的後綴是哪一個。
    \item $\hei(i) = x$代表$S_{B}(\sa(i))$跟$S_{B}(\sa(i-1))$前$k$個字元相同，也就是說如果$S_{B}(\sa(i)) = S_1, \: S_{B}(\sa(i-1)) = S_2$，則$S_1[0, k-1] = S_2[0, k-1]$。我們特別規定$\hei(0) = 0$。
  \end{enumerate}
\end{theorem}
這邊一定不能搞混，$\rank(i)$表示``$i$是第幾名"，而$\sa(i)$表示``誰是第$i$名"，兩者互為反函數。舉個列子，對於字串 \texttt{"ABAABAAAB"} ：
\begin{center}
\begin{tabular}{c|c|c|l}
  $i$ & $\sa$ & $\hei$ & Suffix \\\hline
  0 & 5 & 0 & AAAB \\
  1 & 6 & 2 & AAB \\
  2 & 2 & 3 & AABAAAB \\
  3 & 7 & 1 & AB \\
  4 & 3 & 2 & ABAAAB \\
  5 & 0 & 4 & ABAABAAAB \\
  6 & 8 & 0 & B \\
  7 & 4 & 1 & BAAAB \\
  8 & 1 & 3 & BAABAAAB
\end{tabular}
\end{center}

在學會如何使用 suffix array 以前，我們得先學會如何建造 suffix array 。而建造 suffix array 的演算法也很多種，最佳的時間複雜度為 $\ord{N}$ 。
但原理複雜，因此這裡我們先介紹一種最基本的倍增算法，複雜度是 $\ord{N \log N } $，但在這之前我們需要一點先備知識。
\begin{theorem}[定理]
  如果$A[0, k-1] = B[0, k-1]$我們便寫作$A =_k B$，相同的道理我們可以定義$A <_k B$，則
  \[ A < B  \quad \Rightarrow  \quad
    \begin{dcases}
      A <_k B &  \text{or} \\
      A =_k B \; \land \; S_A(k) < S_B(k)  &
    \end{dcases}
  \]
\end{theorem}
其實就是說假定今天$A < B$，且$A = A_1A_2, B = B_1B_2, \; \abs{A_1} = \abs{B_1}$，那麼不是$A$在第一階段就比輸了$A_1 < B_1$，就是在第二階段才比輸， $A_1 = B_1 \text{ and } A_2 < B_2$。\\
藉由這個性質，我們可以觀察到一件很重要的事情：如果我們已經知道所有後綴在只比較他們的前 $k$ 個字元時的大小關係，那麼我們其實可以快速的找出比較前 $2k$ 個字元時的大小關係，因為任何後綴的最後$k$個字元也是原本字串的某個後綴的前$k$個字元！因此倍增的做法便是
\begin{enumerate}
    \item 使用某種方法讓所有後綴依照第一個字元排好
    \item 基於上方結果，讓所有後綴依照前 $2$ 個字元排好
    \item 基於上方結果，讓所有後綴依照前 $4$ 個字元排好
    \item ....
    \item 基於上方結果，讓所有後綴依照前 $2^{\lceil\log_2 |A|\rceil}$ 個字元排好
\end{enumerate}
祥細的流程如下，定義$\rank_k(i)$表示依照前 $k$ 個字元排序時，比第$i$個後綴
小的有幾個(也就是名次，只是相等的名次一樣)
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[mynode/.style=draw, minimum width=3cm, minimum height=1cm, align=left]
    \node at (0, 0) [mynode] {先求出$\rank_1(i)$};
    \node at (4.5, 0) [mynode] {用$(\rank_k(i), \rank_k(i+k))$\\排序得出$\sa_{2k}(i)$};
    \node at (9.4, 0) [mynode] {利用$\sa_{2k}$求出$\rank_{2k}$};
    \node at (7.2, 1.2) {總共$\ceil{\lg n}$次};
    \draw[-latex, thick] (1.6, 0) -- ++(0.8, 0);
    \draw[-latex, thick] (6.6, 0) -- ++(0.8, 0);
    \draw[-latex, thick] (9.4, 0) ++ (0, 0.6) |- (4.5, 1.5) -- ++(0, -0.8);
    \draw[-latex, thick] (11.5, 0) -- ++(1, 0);
  \end{tikzpicture}
  \caption{}
  \label{fig:sa1}
\end{figure}
從 Figure~\ref{fig:sa1} 中我們知道瓶頸在排序$(\rank(i), \rank(i+k))$，假設一次的時間複雜度是$\ord{F}$，那總體的複雜度就是$\ord{\log(n) F}$。如果我們用一般的排序法$\ord{F} = \ord{n \log n}$，但因為我們要排的東西都是兩個$[0, n)$中的整數對，可以使用 Radix sort 加速到 $\ord{n}$ ，因此總共的複雜度就是  $\ord{n \log n}$了。

最後我們只剩$\hei$要求了。複習一下$\hei$的定義，$\hei(i)$代表$S_{B}(\sa(i))$跟$S_{B}(\sa(i-1))$前幾個字元相同。我們先列出他的一些性質：
\begin{theorem}[定理]
  我們定義$d(A_1, A_2)$表示$A_1, A_2$的前幾個字元相同。對於一個長度為$n$的字串$B$有：
  \begin{itemize}
    \item 假設$\rank(i) < \rank(j)$，則 $ d(S_B(i), S_B(j)) = \min\limits_{\rank(i) < k \leq \rank(j)} \hei(k) $ \listeqn \label{eq:sa1}
    \item 如果$\hei(\rank(i)) = k$，則字典序比 $S_B(i)$ 小的字串最多只會跟 $S_B(i)$ 前 $k$ 個字元一樣。 \listeqn \label{eq:sa2}
    \item $\hei(\rank(i)) \geq \hei(\rank(i-1)) - 1$ \listeqn \label{eq:sa3}
  \end{itemize}
\end{theorem}
其實按照字典序排序的結果就是，長的像的後綴會被排在一起！
我們先證 \eqref{eq:sa1} ，假設$\rank(i) = k_1, \rank(j) = k_2$，注意到
$\hei(k_2)$ 表示 $S_B(\sa(k_2)), S_B(\sa(k_2-1))$ 前幾個字元一樣，$\hei(k_2 - 1)$ 表示 $S_B(\sa(k_2 - 1)), S_B(\sa(k_2-2))$ 前幾個字元一樣...，一直到 $\hei(k_1 + 1)$ 表示 $S_B(\sa(k_1 + 1)), S_B(\sa(k_1))$ 前幾個字元一樣。但別忘了
\[
  S_B(\sa(k_1)) = S_B(\sa(\rank(i))) = S_B(i),\quad S_B(\sa(k_2)) = S_B(\sa(\rank(j))) = S_B(j)
\]
因此 $S_B(i), S_B(j)$ 至少前$h = \min_{k_1 < k \leq k_2} \hei(k)$個字元一樣！但 $h = \min_{k_1 < k \leq k_2} \hei(k)$，表示一定有一次 $S_B(\sa(k')) $ 和 $S_B(\sa(k'-1))$的第$h$個字元不一樣。而之後這第 $h$ 個字元也不可能一樣，因為我們是照字典序排序的，接下來只會越來越小！因此 \eqref{eq:sa1} 是對的！\\
\eqref{eq:sa2} 是 \eqref{eq:sa1} 的一個直接的結果，而 \eqref{eq:sa3} 我們用圖來說明 \\

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=0.8]
    \fill[gray!30] (1, 0) rectangle (5, 1);
    \fill[gray!30] (8, 0) rectangle (12, 1);
    \draw[line width=0.8mm] (0, 0) rectangle (5, 1);
    \draw[line width=0.8mm] (7, 0) rectangle (12, 1);
    \draw (0, 0) rectangle (14, 1);
    \draw[thick] (0, 0) rectangle (1, 1) coordinate[midway](v1);
    \draw[thick] (1, 0) rectangle (2, 1);
    \draw[thick] (7, 0) rectangle (8, 1) node[midway, yshift=-0.8cm] {$i-1$};
    \draw[thick] (8, 0) rectangle (9, 1) node[midway, yshift=-0.8cm] {$i$};
    \draw (0, 0) rectangle (14, 1);
    \draw[decoration={brace, raise=1.5mm, amplitude=1.5mm}, decorate, thick] (0, 1) -- (5, 1)
    node[midway, yshift=0.7cm] {$\hei(\rank(i-1))$};

    \draw[decoration={brace, raise=1.5mm, amplitude=1.5mm}, decorate, thick] (8, 1) -- (12, 1)
    node[midway, yshift=0.7cm] {$\hei(\rank(i-1)) - 1$}
    ;

    \draw[latex-] (v1) ++ (0, -0.7) -- ++(0, -0.6) node[below]{$\sa(\rank(i-1)-1)$};
    
  \end{tikzpicture}
\caption{}
\label{fig:sa2}
\end{figure}

如Figure~\ref{fig:sa2}，假設$\hei(\rank(i-1)) = k$，且不妨假設$k > 1$，也就是說$S_{B}(i-1)$和他照字典序排序後的前一號$j = \sa(\rank(i-1)-1)$的前$k$個字元一樣！則$S_B(j+1) < S_B(i)$因為$S[j] = S[i-1]$，且$S_B(j+1)$至少會和$S_B(i)$有$k-1$個字元一樣。由\eqref{eq:sa2}我們得知
\[
  \hei(\rank(i)) \geq k - 1 = \hei(\rank(i-1)) - 1 
\]

\subsection{Suffix Array 之應用}
第一個 Suffix Array 主要的應用是處理匹配問題，而且他往往比前面介紹的演算法更有彈性！ 

我們用 $B$ 去匹配 $A$ 其實就是在問 $B$ 是不是 $A$ 的一個子字串。 注意到一個子字串又一定是某個後綴的前綴，所以我們要做的事情就是找出 $A$ 和 $B$ 最像的後綴，也就是{\bf 問如果我們將$A$的後綴排序好後， $B$ 在其中的哪個位置？}而排序的部分剛好就是Suffix Array 做的事情。 而找出 $B$ 在其中的位置，很顯然會想到二分搜。 這樣的確只需要比較 $\ord{n \log n}$ 次，不過因為後綴的長度可以到 $\ord{n}$ ，所以整體下來會是 $\ord{n \log n}$。

一個優化是，假設我們已經將 $B$ 和一個 $A$ 的後綴 $S_A(i)$ 匹配了前 $k$ 個字元， 現在我們要匹配另一個後綴 $S_A(i')$ ， 注意到如果 $B$ 可以和 $S_A(i')$ 匹配超過 $k$ 個字元，那麼 $S_A(i), S_A(i')$ 至少要前 $k$ 個字元相同 (更甚者，要恰好前 $k$ 個字元相同)。也就是 $d(S_A(i), S_A(i')) \geq k$。於是 \eqref{eq:sa1} 告訴了我們
\[ d(S_A(i), S_A(i')) = \min\limits_{\rank_A(i) < k \leq \rank(i')} \hei(k) \]
這其是一個RMQ問題，如果我們用如{\bf 線段樹}等資料結構加速，每一次的查詢只需要 $\ord{\log n}$  甚至 $\ord{1}$ \footnote{ 因為我們不需修改操作，其實 RMQ 是可以做到 $\ord{1}$ 的，當然，不是很好實做。 }。
而如果查詢的結果是 $d(S_A(i), S_A(i')) < k$ ，我們就不需要在重新匹配了，而如果 $d(S_A(i), S_A(i')) = k$ 時我們直接繼續從第 $k$ 個字元匹配。 這樣成功匹配的數量(也差不多會是匹配的次數) 永遠只會增加， 因此匹配的次數不會超過 $\ord{\abs{B}}$ ， 全部的複雜度會是 $\ord{ \abs{A} \log \abs{A} + \abs{B} }$。

第二個應用可以處理字串中的計數問題，我們先考慮一個最基本的問題
\SampleProblem[經典問題]{不同的子字串數}{ 給你一個字串 $A$ ，問$A$不同的子字串有幾個。比如 $A = \str{abab}$，不同的子字串有 $\str{a}, \str{b}, \str{ab}, \str{ba}, \str{aba}, \str{bab}, \str{abab}$，共 $7$ 種。}
這邊還是用到一個子字串一定是一個後綴的前綴。如果一個子字串出現在多個後綴，我們在字典序最小的後綴計算，你會發現，$\hei(i)$就會剛好是$\rank(i)$的後綴的前綴中，有多少已經在字典序比他小的後綴出現過。因此
\[ {n \choose 2} - \sum_{i=1}^{n-1} \hei(i) , \quad \text{where } n = \abs{A} \]
恰好就是答案。

\section{Suffix Automaton*}
後綴字動機 (Suffix Automaton) 是現在很熱門的一個後綴結構。雖然大部分 Suffix Automaton 可以做到的事情 Suffix Array 也可以做到，但其程式碼精簡，不失為另一個不錯的解題武器。

\begin{theorem}[定義]
  一個字串$B$的後綴自動機是一個自動機，他接受一個字串$s$若且唯若$s$是$B$的一個後綴。
\end{theorem}
如下圖 \ref{fig:sam1} 就是字串$\str{abcbc}$的後綴自動機。
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[>=latex, node distance=2cm, auto]
    \tikzstyle{accepting}=[fill=gray!20, double=gray!20, double distance = 1.5pt]
    \node[state, initial] (q0) {};
    \node[state] (q1) [right of=q0]{};
    \node[state] (q2) [right of=q1]{};
    \node[state] (q3) [right of=q2]{};
    \node[state] (q4) [right of=q3]{};
    \node[state, accepting] (q5) [right of=q4]{};
    \node[state] (q6) [above right of=q1, yshift=1cm, xshift=-1cm]{};
    \node[state, accepting] (q7) [right of=q6, xshift=1cm]{};
    \path[->]
    (q0) edge [swap] node {a} (q1)
    (q1) edge [swap] node {b} (q2)
    (q2) edge [swap] node {c} (q3)
    (q3) edge [swap] node {b} (q4)
    (q4) edge [swap] node {c} (q5)
    (q0) edge        node {b} (q6)
    (q0) edge        node {c} (q7)
    (q6) edge        node {c} (q7)
    (q7) edge        node {b} (q4)
    ;
  \end{tikzpicture}
\caption{}
\label{fig:sam1}
\end{figure}
至於如何構造？最基本的想法就是把所有$B$的{\bf 子字串}都當作自動機上的一個 state，然後一個一個 state 慢慢建邊。這樣當然正確性是被保證的(畢竟所有後綴的前綴一定是原字串的一個子字串)，但這樣 state 有 $\ord{N^2}$ 個，需要再改進。\\
而減少 state 的唯一方法就是把等價的 state 合併。像 Figure~\ref{fig:sam1} 中 state 數量也只有 $8$ 個而非 ${6 \choose 2} = 15$ 個那麼多，觀察後可以發現在圖中 $\str{abcb},\str{bcb},\str{cb}$ 三個字串是屬於同一個 state 的！\\
仔細思考一陣後可以發現，只要結束位置相同的兩個子字串，他們的 state 就會是等價的，我們便可以將之合併！我們先定義結束集合

\begin{theorem}[定義]
  給定兩個字串$B, T$，我們定義$T$在$B$上的結束集合$\edps_B(T)$為
  \[
    \edps_B(T) = \{ i ~:  B[ i - \abs{T} + 1 , i ] = T \}
  \]
\end{theorem}
比如說對$\str{abcbc}$而言，$\edps(\str{bc}) = \{2, 4\}$，因為$\str{bc}$在字串中出現兩次並且分別在位置$2, 4$結束。

\begin{theorem}[定理]
  給定兩個字串$T_1, T_2$，如果$\edps_B(T_1) = \edps_B(T_2)$，記作$T_1 \equiv_B T_2$，則
  \begin{itemize}
    \item 對任何字串$A$，$\edps_B(T_1 A) = \edps_B(T_2 A)$，也就是$T_1 A \equiv_B T_2 A$ \listeqn \label{eq:sam1}
    \item 對任何字串$A$，如果$T_1 A$是$B$的後綴，則$T_2 A$也是$B$的後綴 \listeqn \label{eq:sam2}
  \end{itemize}
\end{theorem}

\eqref{eq:sam1} 稍為推敲即可得出，而 \eqref{eq:sam2} 是前者的一個直接推論，並且 \eqref{eq:sam2} 也告訴我們，只要 $T_1 \equiv_B T_2$，他們的確可以看作是等價的 state ！如在前面的例子，$\edps(\str{bc}) = \{2, 4\} = \edps(\str{c})$，而他們在 Figure~\ref{fig:sam1} 上也的確會走到同一個 state 。\\
但這樣可以幫我們省下多少 state 呢？ 我們還需要$\edps$的一個很重要的性質：

\begin{theorem}[定理]
  給定兩個字串$T_1, T_2$，$\abs{T_1} < \abs{T_2}$，那麼不是
  $ \edps(T_1) \cap \edps(T_2) = \varnothing $，就是
  $ \edps(T_1) \supset \edps(T_2) $。並且如果是後者，$T_1$會是$T_2$的一個後綴。 \listeqn
\end{theorem} 
事實上從這個定理我們就可以知道state的數量最多只會有 $2n - 1$ 個。我們在這邊整理一下：\\

\begin{theorem}[定理]
  我們可以用 $\equiv_B$ 將 $B$ 的所有子字串分類，也就是$T_1, T_2$被分在同一類若且唯若 $T_1 \equiv_B T_2$ 。假設我們將 $B$ 的所有子字串分成 $\alpha_1, \alpha_2 , \cdots , \alpha_k$，則
  \begin{itemize}
    \item 如果$t_1, t_2 \in \alpha_i$，則必有其中一個為另一個的後綴。 \listeqn \label{eq:sam3}
    \item $k$ 恰好是後綴自動機上非起始節點的數量，每一個$\alpha_i$可以看做是後綴自動機上的一個 state 。
    \item $k < 2 |B| - 1$。
  \end{itemize}
\end{theorem}

在後綴自動機還有一個很重要的指標，Fail link $\flk$。假設一個字串 $T_0$ 是 $B$ 的子字串，那我們如果不斷把 $T_0$ 的第一個字串去掉變成 $T_1, T_2, \cdots$，那一開始結束集合可能不變，但總會有一個 $T_k$ 結束集合開始改變了。 比如說 $B = \str{ababa}$ ， $\str{abab}, \str{bab}$ 的結束集合都是 $\{ 4 \}$ ，但 $\str{ab}$ 的結束集合變成 $\{ 2, 4 \}$ 了。\\
假設 $T_0$ 所屬的集合稱作 $\alpha_1$ ， $T_k$ 所屬的集合稱作 $\alpha_2$ ，則令 $\flk(\alpha_1) = \alpha_2$。

\begin{theorem}[定理]
  我們定義 $\edps(\alpha_i) = \edps(t_1)$，對於任意一個 $t_i \in \alpha_i$。(反正任何一個的結束集合都一樣)。\\
  定義 $\max(\alpha_i), \min(\alpha_i)$為$\alpha_i$裡最長/短的字串(因為 \eqref{eq:sam3} 所以恰好只會有一個)。\\
  我們用$\alpha(t)$來表示字串$t$所屬的集合，如果$s_i = \min(\alpha_i)$，我們定義
  \[
    \flk(\alpha_i) = \alpha(S_{s_i}(1))
  \]
  也就是把$s_i$的第一個字元去掉後所屬的類別。
\end{theorem}

現在我們要考慮怎麼樣把這一個後綴自動機建出來。一個做法是我們從空字串開始，一個一個字元慢慢加上去。因為$\alpha_i$就是後綴自動機上的點，所以我們要先了解$\edps(t)$會怎麼變動。
\begin{theorem}[定理]
  給定$B$，現在如果在$B$的後面加一個字元$c$使得$B' = Bc$，則如果$T$是$B$的一個子字串，有
  \begin{itemize}
    \item 如果$T$不是$B'$的一個後綴，那$\edps_{B'}(T) = \edps_B(T)$。
    \item 如果$T$是$B'$的一個後綴，那$\edps_{B'}(T) = \edps_B(T) \cap \{n\}$，其中$n = \abs{B} = \abs{B'} - 1$。
  \end{itemize}
\end{theorem}
這個定理告訴我們，在一個字串後面加一個字元，結束集合不會有太大的變動！會變的只有$B'$的後綴，不超過$n$個，而且分在同一類的可以一起處理！現在的問題就只有{\bf 怎麼找出所有後綴存在的集合了}。這時候就可以好好利用 $\flk$ 了！

\begin{theorem}[定理]
  給定一個字串$B$，$B'$ 為在 $B$ 後面加一個字元 $c$ 所成的字串， 即 $B' = B c $ 。
  \begin{itemize}
    \item 假設 $T'$ 是 $B'$ 的後綴， 則 $B = Tc$，其中 $T$ 是 $B$ 的後綴。
      \listeqn  \label{eq:bc1}
    \item 令 $\beta_0 = \alpha(B)$ ， 也就是整個字串 $B$ 所屬的集合，如果  $\flk(\beta_i) = \beta_{i+1}$ ， 則所有 $B$ 的後綴都會在 $\{ \beta_0, \beta_1, \cdots, \beta_h \}$的其中一個。 \listeqn \label{eq:bc2}
  \end{itemize}
\end{theorem}

將 \eqref{eq:bc1} 和 \eqref{eq:bc2} 合起來用，我們就得出一個找到 $B'$ 所有後綴的方法了！ 我們只要檢查 $\{ \beta_0, \beta_1, \cdots \}$ 有沒有連出 $c$ 的邊，有的話所有那些點就是 $B'$ 的後綴了。最後我們只要考慮這些點的結束位置會怎麼變就可以了。

\begin{theorem}[定理]
  給定一個字串$B$：%
  \begin{itemize}
    \item 現在如果在$B$的後面加一個字元$c$使得$B' = Bc$，則如果$T$是$B'$的後綴，且$T$是$B$的子字串，那$T$的所有後綴也是$B$的子字串。     
    \item 存在$k$使得所有$j \geq k$，$S_B(j) c$，也就是在$S_B(j)$後面加一個字元$c$，都是$B$的子字串。而所有$j < k$，$S_B(j) c$都不是$B$的子字串。\listeqn \label{eq:bc3}
  \end{itemize}
\end{theorem}
也就是說會有一個臨界的後綴$S = S_B(k)$，使得比他短的後綴加上 $c$ 後，會是原本 $B$ 的子字串。不妨設 $m = \abs{S}$。令 $\beta_k$ 是第一個有連出 $c$ 的邊的點，由 \eqref{eq:bc3} 我們知道 $\beta_i$ 有連出 $c$ 的邊若且唯若 $i \geq k$。因此可令 $\gamma_i = \beta_i c$，也就是從$\beta_i$連出 $c$ 的邊走到的點。我們現在只要考慮 $\edps(\gamma_i)$，會怎麼變化就可以了！有兩種情形


\begin{enumerate}[label=Case \arabic*. ]
  \item $\abs{\max(\gamma_i)} = \abs{\max(\beta_i)} + 1$，假設 $\max(\beta_i) = T, \max(\gamma_i) = U$，這代表 $Tc = U$ ，而 $\gamma_i$ 裡的字串都是$U$ 的後綴，也就是 {\bf 所有 $\gamma_i$ 中的字串都是 $B' = Bc$ 的後綴}！因此他們的結束位置都全部加一個 $n$，同時改變，不需要分家了。
  \item $\abs{\max(\gamma_i)} > \abs{\max(\beta_i)} + 1$，與前面的 Case 相反，這表示 {\bf 並非所有 $\gamma_i$ 中的字串都是 $B' = Bc$ 的後綴}！這時我們勢必得把 $\gamma_i$ 拆成兩個新的點 $\gamma_{i1}, \gamma_{i2}$ 了。
\end{enumerate}

因此我們必需維護兩個東西，$\flk(\alpha_i)$ 和 $\mx(\alpha_i) = \abs{\max(\alpha_i)}$。
如果你仔細考慮每個 Case 這兩者該如何變化，可以得出以下構造後綴自動機的演算法：\\
我們從一個只有 initial state $\alpha_0$ 的自動機開始，每個點維護$\flk(\alpha_i), \mx(\alpha_i) = \abs{\max(\alpha_i)}$，並且記好結束的 state $e$ 是哪一個(一開始$e = \alpha_0$)，逐一插入字元。假設這一次插入的字元為 $c$ ：
\begin{enumerate}
  \item 加入一個新點 $\alpha_{k+1}$
  \item 從$e$開始，令$u = e$。看看 $u$ 有沒有 $c$ 的出去的邊，如果沒有，則加一條 $c$ 從 $u \rightarrow \alpha_{k+1}$的邊。 令 $u \leftarrow \flk(u)$ 繼續嘗試，直到有或者 $u = \alpha_0$為止。
  \item 如果$u$沒有 $c$ 連出去的邊，則$u = \alpha_0$，加一條 $c$ 從 $\alpha_0 \rightarrow \alpha_{k+1}$並令$\flk(\alpha_{k+1}) = \alpha_0$後結束。
  \item  現在假設$u$ 從 $c$ 連出去的邊到 $v$。
  \item 如果$\mx(v) = \mx(u) + 1$，(Case 1.)則讓$\flk(\alpha_{k+1}) = v$，結束。
  \item 如果$\mx(v) \neq \mx(u) + 1$，(Case 2.)我們需要把$v$拆成兩個點。因此我們複製一個點$v'$使得
    \begin{itemize}
      \item $v'$要保持$v$的所有向外的邊。
      \item $\flk(v') \leftarrow \flk(v), \quad \flk(v), \flk(\alpha_{k+1}) \leftarrow v'$。
      \item 所有$u$往$\flk(u)$走到的節點如果有邊指向$v$要改指到$v'$。因此我們不段令$u \leftarrow \flk(u)$去檢查，直到$u = \alpha_0$為止。
    \end{itemize}
\end{enumerate}
最後更新$e = \alpha_{k+1}$，增加$k$後重複步驟直到建完整個字串。\\
以下是一個 Suffix Automaton 的範例程式碼：
\SourceCode[naive-matching]{suffix-machine.cc}{16}{41}
Suffix Automata 的應用非常多，從匹配到計數等等。另外 Suffix Automata 有一個很重要的性質：
\begin{theorem}[定理]
  一個 $B$ 的後綴自動機上從起始點 $s$ 到任何一點 $v$ 的任何一條路徑都恰好對應到一個 $B$ 的子字串。
\end{theorem}
因此會有各種在 Suffix Automata 上 DP 的花招，就留給讀者自行探討了。

\section{習題}

  %\setcounter{subsection}{-1}
  %\subsection{Preliminary}
    %\ExerciseProblem[基本知識]{String in C/C++}{
      %俗話說的好，工欲善其事，必先利其器。在學習任何字串演算法前，也要先熟悉C/C++裡的字串操作，不然題目來了還是無從下手！而字串的儲存可以用\texttt{char} Array, 也可以用C++裡的\texttt{std::string}，請熟悉這兩種的各種操作，輸入/出，以及相關的內建函數(如比較函數等等)。並指出下面程式的問題所在。
    %}
    
  \subsection{String Matching}
    \ExerciseProblem[經典問題]{ABA}{
    給定字串$S$，求出最長的$A$使得$S = ABA$。$\cons{\ord{\abs{S}}}$
    }

    \ExerciseProblem[POI XIII]{Periods of Words}{
      給定字串$S$，求出最長的$A$使得 $A$ 是 $S$ 的前綴且 $S$ 是 $AA$ 的前綴。$\cons{\abs{S} \leq 10^6}$
    }

    \ExerciseProblem[POI XII]{Template}{
      給定字串$S$，求出最短的$A$使得 $A$ 可以覆蓋 $S$ 。 比如說 $\str{abaabaab}$ 可以用兩個 $\str{abaab}$ ，分別開頭在 $0, 3$ 蓋住。$\cons{\abs{S} \leq 10^6}$
    }

    \ExerciseProblem[經典問題]{近似匹配}{
      給定字串$A, B$，以及一個整數$k$，求出所有$B$在$A$中$k$幾乎匹配的位置。我們稱$A[i, i+n-1], B[j, j+n-1]$是$k$幾乎匹配如果$\{ A[i+x] \neq B[j+x], \: 0 \leq x \leq n-1 \}$的個數不超過$k$個。 $\cons{\ord{k\abs{A} + \abs{B}}}$
    }

    \ExerciseProblem[TIOJ 1735 / Kelvin]{k-口吃子字串}{
      定義一個$k$-口吃字串為某一個長度為 $k$ 的字串重複兩次的字串。如 $\str{abcabc}, \str{aaaaaa}$ 都是 $3$-口吃字串。給一個字串$S$和 $k$ ，請問有多少 $(i, j)$ 滿足 $S[i, j]$ 是 $k$-口吃字串。  \\
      $\cons{\abs{S} \leq 10^5}$ 
    }

    \ExerciseProblem[經典問題]{KMP and Z value}{
      給你一個字串的 fail function $\fail$ 和他的長度 $n$ (也就是說你並不知道原本的字串) ，請求出他的 Z value $Z$ 。 
      反之亦然，給你一個字串的 Z value $Z$ ，請求出他的 fail function $\fail$ 。 
      $\cons{ \ord{n} }$
    }

    \ExerciseProblem[TIOJ 1725]{Massacre at Camp Happy}{
      定義兩個字串$A, B$是$k$-幾乎相同如果把 $A$ 的前 $k$ 個字元搬到最後面，那兩者恰相差一個字元，給你 $A, B$ ， 求出所有的 $k$ 使得他們是 $k$-幾乎相同。 $\cons{ \abs{A} = \abs{B} \leq 10^6 }$
    }

    \newcommand{\ZZ}{\operatorname{\mathcal{Z}}}
    \ExerciseProblem[經典問題]{最長回文子字串}{
      給一個字串 $A$ ，求出他最長的一個回文子字串。 $ \cons{ \ord{ \abs{A}} }$

      這題可以用類似 Z-algorithm 的方法。我們先考慮如何求最長的{\bf 奇數}回文子字串。 令 $\ZZ(i)$表示以$i$為中心最長的回文字串為 $A[i-\ZZ(i), i+\ZZ(i)]$。 現在假設$(L, R) = (i-\ZZ(m), i+\ZZ(m))$, 即$A[L, R]$是一個以$a[m]$ 為中心的回文。如果 $j \in [m+1, R]$，考慮 $j' = 2m - j$，即$j$對$m$的反射點。現在與Z-algorithm類似，令 $L' = j - \ZZ(j')$，分別考慮 $L' > L, L' = L , L' < L$ 三種情況。

      但此方法僅能求得奇數的回文長度。因此我們把原字串相鄰的兩個字元都插入一個不在字元集 $\Sigma$ 中的字元，如 $A = \str{abbab} \; \rightarrow A' = 
  \str{a\$b\$b\$a\$b}$，這樣所有回文的長度都變成奇數了。
    }

    \ExerciseProblem[Codeforces Zlobober's blog]{Anti-hash text}{
      在 Hashing 實作上，因為 C++ 的模運算 \texttt{\%} 是非常花時間的，因此有一種 Lazy hash 的方法是 直接 $\bmod{2^{32}}$ 或是 $\bmod{2^{64}}$，這樣直接在 $\texttt{int}, \texttt{long long}$ 下做運算就可以了。但這樣做有其風險在，以下說明其原因。

      不妨假設此 Hash function 為
      \[ f(A) = \sum_{i=0}^{n-1} a_i p^{n-1-i} \bmod{q} \]
      其中 $p$ 為一奇數(否則此 Hash function 無意義)，$q = 2^m$，並且 $\str{a}, \str{b}$ 轉換成數字後分別為 $\alpha, \alpha + 1$ 。此時令
      \[ A_0 = \str{a}, \quad A_j = \widetilde{A}_{j-1} A_{j-1} \]
      其中 $\widetilde{A}$ 表示把字串 $A$ 中的 $\str{a}$ 換成 $\str{b}$， $\str{b}$ 換成 $\str{a}$。如：
      \[ A_1 = \str{ba}, \quad A_2 = \str{abba}, \quad A_3 = \str{baababba}, \quad \cdots \]
      現在考慮 $A_{k}, \widetilde{A}_{k}$，注意這兩個字串恰好是 $A_{k+1}$ 的前後半且 $A_k \neq \widetilde{A}_{k}$。請證明
      \begin{align*}
        f(\widetilde{A}_{k}) - f(A_{k}) &= p^0 - p^1 - p^2 + p^3 -p^4 + p^5 + \cdots + (-1)^{k-1} p^{2^{k}-1} \\
        &= \sum_{i=0}^{2^{k}-1} b_i p^i  \quad = S
      \end{align*}
      其中 $b_i \in \{ 1, -1 \}$，且如果 $i$ 的二進位表示有偶數個 $1$ ，則 $b_i = 1$，否則 $b_i = 0$。並且有
      \[ \sum_{i=0}^{2^{k}-1} b_i p^i = (p-1)(p^2-1)(p^4-1) \cdots (p^{2^{k-1}} - 1) \]
      注意到 $(p^{2^r} - 1)$ 可以被 $2^{r+1}$ 整除 (Why?) ，所以 $S$ 可以被 $2^{1 + 2 + \cdots + k} = 2^{k (k+1)/2}$整除。因此只要 $2^{k(k+1)/2}$ 被 $2^m$ 整除，也就是$\frac{k(k+1)}{2} > m$，$A_{k}$ 和 $\widetilde{A}_{k}$ 的 Hash value 就會相同。因此可以用一個長度為 $2^{\ord{x}}$ 的字串構造出一個使 $q = 2^{\ord{x^2}}$ 的 Hash function 失效的反例，並且與 $p$ 的選擇無關。
    } 

    \ExerciseProblem[經典問題]{二維匹配}{
      給你一個 $R_A \times C_A$ 的二維字串 $A$ ， 問一個 $R_B \times C_B$ 的二維字串 $B$ 有沒有出現在其中？ $\cons{ \ord{ R_A C_A + R_B C_B }}$。

      一個巧妙的做法可參考 Baker-Bird Algorithm，令外也有用 Hash 的方法，令$c = C_B, \; a_i[j] = f(A[i][j, j+c-1])$，原題等價於問 $f(B[0]), f(B[1]), \cdots f(B[R_B-1])$ 是不是等於\\ 
      $a_i[j], a_{i+1}[j], \cdots , a_{i+R_B-1}[j]$。這是一個一維的匹配問題。詳細可參考去年的講義。
    }

    \ExerciseProblem[ACM ICPC 2013-2014 NEERC Northern Subregional]{sed}{
      給你$A, B$，求出字串 $X, Y$ 使得將 $A$ 中的 $X$ 取代為 $Y$ 後會變成 $B$，並且 $\abs{X} + \abs{Y}$ 最短。 取代的定義為找 $X$ 出現在 $A$ 的第一個位置，假設 $A[i, j] = X$ ，立刻將 $A[i, j]$ 變成 $Y$ ，並從 $j+1$ 繼續找下一個 $X$ 直到沒有為止。 $\cons{ \abs{A}, \abs{B} \leq 5000}$。
    }

  \subsection{Suffix structure}
    \ExerciseProblem[經典問題]{最小的後綴}{
      給一個字串 $A$ ，求出他字典序最小的後綴。 $\cons{\ord{\abs{A}}}$

      有不需要建出Suffix Array的方法。 \footnote{Hint: 雙指針}

      這有一些應用，如最小循環表示法。 有時候我們會把一個狀態或物體用一個字串表示，並且可能旋轉需視為相同的，也就是把字串前 $k$ 個字元接到後面視為相同。 這時候如果要比較兩個字串，可以先求他們的最小循環表示在進行比較。
    }

    \ExerciseProblem[經典問題]{重複子字串}{
      給一個字串 $A$ ，求出他最長的一個重複的子字串，重複的部分可以重疊。比如說 $A = \str{cabababc}$，最長的重複子字串為 $\str{aba}$。 $ \cons{ \ord{ \sa } }$ \footnote{ $\ord{ \sa }$ 表示建出後綴數組所需的時間。} \\
      如果改成不能重複呢？ $\cons{ \ord{ \abs{A} \log \abs{A} } }$
    }

    \ExerciseProblem[經典問題]{連續重複的子字串}{
      給一個字串 $A$ ，求出他的連續重複次數最多的子字串。比如說 $A = \str{cababababc}$， $\str{ab}$在子字串$\str{abababab}$中連續重複了$4$次。
    } $\cons{ \ord{ \abs{A} \log \abs{A} } }$

    \ExerciseProblem[ASC 40]{Binary Suffix Array}{
      給定一個 $n$ 個整數的序列 $a_1, a_2, \cdots, a_n$， 找出一個01字串 $A$ 使得 $A$ 的後綴數組 $\sa$
      恰好是給定的序列，注意到有可能無解。
    } $\cons{ \abs{A} \leq 3 \cdot 10^5}$

    \ExerciseProblem[SPOJ 7258]{Lexicographical Substring Search}{
      給一個字串 $A$ ，現在把 $A$ 的所有子字串列出，將重複的刪去後排序。對於 $Q$ 比詢問， 輸出字典序第 $k$ 小的子字串。
    } $\cons{ \abs{A} \leq 90000, Q \leq 500}$

    \ExerciseProblem[NTUOJ 2200]{Beautiful Substring}{
      給一個字串 $A$ ， 把他所有不同的子字串找出來，令這個集合為 $S$ ，接著每次會給一個字串 $B_i$， 假設他所有不同的子字串的集合為 $T_i$， 就令 $S \leftarrow S \setminus T_i$，並輸出此時的 $\abs{S}$，也就是 $S$ 裡還剩多少字串。
    } $\cons{ \abs{A} \leq 2 \times 10^5,\; \sum \abs{B_i} \leq 10^6}$

    \ExerciseProblem[ASC 42]{Incomparable Suffixes}{
      給一個字串 $A$ ， 我們說兩個字串 $s, t$ 是{\bf 可分辨的} 若且為若存在一個字串 $z$ 使得 $sz, tz$ 中恰好只有一個是
      $A$ 的後綴， 說兩個字串 $s, t$ 是 {\bf 無可比較的} 若且為若對所有 $s$ 的前綴 $x$ ， $t$ 的前綴 $y$ ， 
      $x, y$ 都是可分辨的。 現在請找出 $a_1, a_2, \cdots, a_n$ 滿足：
      \begin{enumerate}
        \item 所有 $a_i$ 都是 $A$ 的後綴。
        \item $n$ 越大越好。
        \item 在 $n$ 是所有可能的最大值下， $\sum \abs{a_i}$ 越大越好。
      \end{enumerate}
    } $\cons{ \abs{A} \leq 10^5}$
  \section{Special Thanks}
  此分講義部分參考自去年的講義，特別感謝去年的編輯者。
\end{document}
