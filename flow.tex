%\documentclass[main.tex]{subfiles}
\documentclass[a4paper,12pt]{book}
\input{npsc.tex}  % by little fish (will be the deprecated doc-style)
\input{ioicamp.tex}  % modifications for ioicamp
\usepackage{caption}
\usepackage{csquotes}
\usetikzlibrary{patterns}
\DeclareCaptionLabelFormat{cfig}{圖#2}
\captionsetup{labelformat=cfig}


\begin{document}


\newcommand{\str}[1]{\texttt{"#1"}}
\newcommand{\mcstr}[2]{\texttt{"#1}\cdots\texttt{#2"}}
\newcommand{\ord}[1]{\opord\left(#1\right)}
\newcommand{\abs}[1]{\lvert #1 \rvert}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\ceil}[1]{\lceil #1 \rceil}
\newcommand{\opord}{\operatorname{\mathcal{O}}}
\newcommand{\fail}{\operatorname{\mathcal{F}}}
\newcommand{\flk}{\operatorname{\mathfrak{F}}}
\newcommand{\suf}{\operatorname{\sigma}}
\newcommand{\rank}{\operatorname{\mathcal{R}}}
\newcommand{\sa}{\operatorname{\mathcal{SA}}}
\newcommand{\hei}{\operatorname{\mathcal{H}}}
\newcommand{\edps}{\operatorname{\mathcal{E}}}
\newcommand{\mx}{\operatorname{\mathcal{M}}}
\newcommand{\argmax}{\operatorname{arg\,max}}
\newcommand{\cons}[1]{\left[ \: #1 \: \right]}

\newcommand\numbereqn{\addtocounter{equation}{1}\tag{\theequation}}
\newcommand\listeqn{\hfill\refstepcounter{equation}(\theequation)}
\newenvironment{monobox}{\linespread{0.6}\Verbatim[frame=single, commandchars=\\\{\}]}{\endVerbatim}
\makeatletter

\NewChapter{流}{Flow} 

\begin{comment}
  # Definition
  # Maximum s-t Flow algorithms
  # Models
  # Minimum Cost Maximum Flow algorithms
  # Models
  # Feasible flow
  # Models
  # Advanced topic and misc
\end{comment}

網路流與我們生活中的一些問題息息相關， 比如我們要從一工作站 $s$ 傳輸一個資料
到工作站 $t$ ，傳輸的過程有一些中繼站， 並且某些中繼站間和某些中繼站到工作站
間有傳輸率為 $c$ 的網路線相通，現在要如何找出一個最佳的傳輸方案，使得 $s$ 
到 $t$ 的資料傳輸速率最快？ 

以上就是網路流問題的原型，但隨後人們驚訝的發現網路流還可以用以解決一些看似
無關的問題！如匹配問題、歐拉回路問題等等。網路流的問題千變萬化，常常令人
異想不到，也因此常成為程式競賽的難題，如果能精熟這個領域，便如有了一把解題
的利刃！

\section{前言}

\subsection{問題的定義}
首先我們定義何謂網路流。

\begin{theorem}[定義]
  一個{\bf s-t 網路流}是一張圖(有向或無向) $G = (V, E)$ ， 每條邊上有一個非負的權重
  $c(u, v) \geq 0$ 代表邊的{\bf 流量上限}(如果 $(u, v) \notin E$ 我們定義 $c(u, v) = 0$)。 
  並且有二個特別的點， 源點 $s$ 與 匯點 $t$ 。

  一個{\bf s-t 可行流} 是一個函數 $f : V \times V \mapsto \mathbb{R}$ 滿足以下兩個條件
  \begin{itemize}
    \item \makebox[7cm]{$f(u, v) \leq c(u, v), \; \forall (u, v) \in V \times V$\hfill}
      (流量限制)  \listeqn \label{def:flow1}
    \item \makebox[7cm]{$f(u, v) = -f(v, u), \; \forall (u, v) \in V \times V$ \quad} 
      (流量對稱) \listeqn \label{def:flow1}
    \item \makebox[7cm]{對於所有 $v \in V$ ， 有 $ \sum\limits_{u \in V} f(v, u) = 0 $ \quad} 
      (流量守衡) \listeqn \label{def:flow1}
  \end{itemize}

  而我們定義這個 s-t 流的{\bf 流量}為 \[ \abs{f} = \sum_{v \in V} f(s, v) \]
\end{theorem}

換句話說，我們必須給出每一條邊應往哪個方向流、流多少。 當然，不是隨隨便便流都可以的，
必須滿足這三個限制！

\begin{enumerate}[label=(1.\arabic*) :]
  \item 每條邊的流量都沒有超過他的限制。
  \item 如果 $u$ 往 $v$ 流 $c$ 單位就相當於 $v$ 往 $u$ 流 $-c$ 單位。
  \item 流不能無中生有！ 每一點除了 $s, t$ 以外進去的流量要等於出去的流量，也就是
    淨流量必須是 $0$ 。
\end{enumerate}


\tikzset{vertex/.style={circle, draw, thick, minimum size=.8cm}}
\tikzset{source/.style={vertex, fill=black!20}}
\tikzset{fed/.style={draw, -latex, thick}}
\tikzset{%
  apply style/.code={%
    \tikzset{#1}%
  }
}
\begin{figure}[H]
  \centering
  \input{tikz/flow1.tex}
  \caption{一個流量網路的例子}
  \label{fig:flow1}
\end{figure}

如圖~\ref{fig:flow1} 就是一個流量網路的例子，而右圖則是他的一組解。
讀者可以驗證這個解的確滿足 s-t 可行流的三個限制。

而通常我們會希望流量 $\abs{f}$ 可以越大越好， $\abs{f}$ 最大的
s-t 可行流就稱作{\bf 最大流}。

\section{最大流演算法}
\subsection{剩餘網路}
我們定義了最大流後，現在的問題是要如何找出一個最大流以及他的流量呢？

一個最基本的想法應該是這樣子：不斷的增加流量，直到流滿為止。但如何
「增加流量」，又何謂流滿呢？ 觀察一下可以發現，如果我們可以找到一
條從 $s$ 到 $t$ 的路徑，而且路徑上的邊都還有剩餘流量，那我們就可以
延著這條路徑擴充容量！

\begin{figure}[H]
  \centering
  \input{tikz/flow2.tex}
\end{figure}

因此我們就有以下的方法擴充容量：把圖上所有還沒流滿的邊都拿出來，
如果這些邊構成了一個從 $s$ 到 $t$ 的路徑，那我們就延著這條邊
增加流量。而直到沒有一條從 $s$ 到 $t$ 的路徑，我們就說已經
「流滿」了！

但這個演算法真的是正確的嗎？很不幸的，以下就是一個簡單的反例。

\begin{figure}[H]
  \centering
  \input{tikz/flow3.tex}
  \caption{一個反例，粗邊表示還沒流滿的邊。\\雖然沒有 $s$ 到 $t$ 的路徑，但
  右圖才是最佳解。}
\end{figure}

其實我們以經非常接近答案了， 只是因為我們少考慮了一種「可以流」
的情況！

\begin{figure}[H]
  \centering
  \input{tikz/flow4.tex}
  \caption{}
  \label{fig:flow4}
\end{figure}

如圖~\ref{fig:flow4} 所示，假設 $(u, v)$ 的流量上限是 $5$ ，而已經流了
$3$ 單位的流量。 我們可以增大流量，相當於再流 $x$ 單位過去，也可以
減少流量，{\bf 其實相當於流 $x$ 單位回來！}

因此我們定義剩餘流量如下：

\begin{theorem}[定義]
  一個邊的{剩餘流量} $r(u, v)$ 定義為 \[ r(u, v) = c(u, v) - f(u, v) \]
  如果 $r(u, v) > 0$ ，則可以沿著這些邊擴充流量，因此 $r(u, v) > 0$ 
  的所有邊構成的圖就稱作 {\bf 剩餘網路} ，對於一個流 $f$ 記作 $G_f$。
\end{theorem}
比如圖~\ref{fig:flow4} 中 $r(u, v) = c(u, v) - f(u, v) = 2$，至於 $r(v, u)$ ，
因為 $(v, u)$ 沒有(有向)邊，所以可以看作 $c(v, u) = 0$ ，因此 $r(v, u) = 
c(v, u) - f(v, u) = 0 - (- f(u, v)) = 3$ 。

如果我們把反向的剩餘流量也考慮進去後，之前的演算法就是正確的了！
也就是我們只要不斷在剩餘網路中找 $s \leadsto t$ 的擴充路徑增加流量，
直到沒有 $s \leadsto t$ 的路徑存在後，我們就找到最大流了。

\subsection{對偶}
讓我們先暫停一會兒，來看看什麼是對偶問題。

我們遇到的問題往往是一體兩面的，在求某個問題的最小值其實就是在求
另一個問題的最小值。 比如說「某A最多可以有幾個蘿莉在身旁還能保持
理智」其實就是在問「要陷害某A去坐牢最少要準備多少蘿莉」。或著「
給你 1000 元你最多可以活幾天」其實就跟「你要活一個月至少需要多少
錢」是同一類問題。

那最大流的對偶問題是什麼呢？想像一下今天你家裝了光世代 1G ，回家
開 speedtest.net 測速發現只有 10M ，為什麼會這樣呢？原因就在
光世代 1G 只是把你家出去的那條網線路換成 1G 流量而已，而網路連線
要經過很多條線路，如果有一條線路只有 10M 的流量，那不管從你家出
去的那條網路線有多快，瓶頸永遠卡在那條慢網路網。

這告訴了我們一件事情：
\begin{displayquote}
  你的網速的最大值，就是途中經過的那些網路線中流速的最小值
\end{displayquote}
對最大流問題來說，就是
\begin{displayquote}
  {\bf 一個網路的最大流，就是把 $s$ 和 $t$ 卡住的那些邊的流量總和的
  最小值。}
\end{displayquote}
我們把這個敘述用正式一點的語言描述：
\begin{theorem}[定義]
  一個 {\bf s-t 割}(cut) $C$ 是一個圖的分割，將圖中的點分成兩個集合 $C = (S, T)$，
  滿足 $s \in S, \; t \in T$。我們定義這個割的大小為
  \[ \abs{C} = \sum_{u \in S} \sum_{v \in T} c(u, v). \]
  也就是所有滿足 $u$ 在 $S$，$v$ 在 $T$ 的邊 $(u, v)$ 的流量上限合。\\
  (並不計算 $u$ 在 $T$ ， $v$ 在 $S$ 的邊。)

  一個 {\bf 最小割}就是最小的一個割。
\end{theorem}
{\bf 而一個圖的最大流就是最小割的大小！}
\begin{figure}[H]
  \centering
  \input{tikz/flow5.tex}
\end{figure}

我們用以下這個定理做總結。

\begin{theorem}[Max-flow min-cut theorem]
  對一個流量網路 $G$，以下三件事情是等價的。
  \begin{enumerate}
    \item $f$ 是一個 s-t 最大流。
    \item 關於 $f$ 的剩餘網路 $G_f$ 沒有從 $s$ 到 $t$ 的擴充路徑。
    \item $\abs{f} = \abs{C}$，其中 $C$ 是最小 s-t 割。
  \end{enumerate}
\end{theorem}

\subsection{Ford–Fulkerson algorithm}
之前以經說過，就算忘了 Max-flow min-cut theorem 再提醒了我們一次
只要不斷在剩餘網路中找 $s \leadsto t$ 的擴充路徑增加流量，
直到沒有 $s \leadsto t$ 的路徑存在後，就可以找到最大流了。
因此一個最簡單的演算法如下。

\begin{algorithm}[H]
  \DontPrintSemicolon
  \caption{Ford-Fulkerson algorithm}\label{euclid}
  \SetKwFunction{FF}{FordFulkerson}
  \SetKwFunction{AAP}{AugmentAlongPath}
  \SetKwProg{myalg}{Algorithm}{}{}
  \myalg{\FF{}} {
  \While{We could find an augmenting $P$ path from $s$ to $t$}{
    $\Delta f \gets \AAP{P}$ \;
    $f \gets f + \Delta f$ \;
  }
}
\end{algorithm}
這邊有幾個問題要注意
\begin{enumerate}
  \item 如何找一個擴充路徑？\\
    基本上可以直接遞迴下去做(相當於最普通的 DFS)即可。
  \item 找到了擴充路徑 $P$ 後，如何擴充？\\
    首先顯然增加的流量就是{\bf 路徑上剩餘流量的最小值}， 
    $\Delta f = \min\limits_{e \in P} r(e)$。
    之後我們便將路徑上的邊的流量都加 $\Delta f$，但別忘了由定義
    $f(u, v) = -f(v, u)$，也就是我們必須把反向的邊的流量減掉！
    因此我們總結 $f, r$ 的變化，假設 $(u, v) \in P$：
    \begin{align*}
    f(u, v) \gets f(u, v) + \Delta f, \quad r(u, v) \gets r(u, v) - \Delta f \\
    f(v, u) \gets f(v, u) - \Delta f, \quad r(v, u) \gets r(v, u) + \Delta f \\
    \end{align*}
  \item 圖的儲存：\\
    由於 $c, f, r$ 只要知其二便可知剩下的一個，因此只需要存任兩個就好！
    不過在 2. 我們發現其實只要知道 $r$ 我們就知道 $\Delta f$ 了，因此
    {\bf 在大部分的情況下，只需要存 $r$ 就足夠了}。而在一開始時，
    $f = 0$，因此 $r = c$。
\end{enumerate}
但還有一個最重要的問題，要做幾次擴充路徑這個演算法才會結束呢？很遺憾的是
Ford-Fulkerson algorithm 沒有辦法給出一個好的次數上限！事實上有：
\begin{itemize}
  \item 如果流量上限都是整數，那麼這個演算法最差要做 
    $\ord{\abs{f}}$ 次的擴充，其中 $\abs{f}$ 是最大流的流量。
    總時間複雜度是 $\ord{\abs{E}\abs{f}}$。
  \item 如果流量上限有無理數，那麼這個演算法無法保證會結束！
\end{itemize}
但神奇的是，我們只需要改變一點就可以改進這個演算法！
\subsection{Edmonds-Karp algorithm}
Edmonds-Karp algorithm 是 Ford-Fulkerson algorithm 的一個小改進，他的
演算法如下：

\begin{algorithm}[H]
  \DontPrintSemicolon
  \caption{Ford-Fulkerson algorithm}\label{euclid}
  \SetKwFunction{FF}{FordFulkerson}
  \SetKwFunction{AAP}{AugmentAlongPath}
  \SetKwProg{myalg}{Algorithm}{}{}
  \myalg{\FF{}} {
  \While{We could find an \textit{\textbf{shortest}} augmenting $P$ path from $s$ to $t$}{
    $\Delta f \gets \AAP{P}$ \;
    $f \gets f + \Delta f$ \;
  }
}
\end{algorithm}
咦！怎麼好像一點差別也沒有？ 要仔細看！ 原來之前 Ford-Fulkerson algorithm
是隨便找一條擴充路徑，現在 Edmonds-Karp 規定每次找的擴充路徑要是{\bf 最短
  的一條}。

令人意外的，加上了這個優化之後，可以證明最多只會找 $\ord{VE}$ 次擴充路徑，
不論流量是不是無理數！有時候一個小小的優化也可以造成很大的改變。

\section{最大流模型}
知道了如何解最大流問題之後，我們就可以開始解一些題目了。
\SampleProblem[UVa 820]{Internet Bandwidth}{ 
  現在有一些機器可以互相傳訊，但兩個機器 $u, v$ 間會有一個
  傳訊的頻寬上限 $c(u, v)$ ，問你從機器 $s$ 傳訊到 $t$ 的
  最大頻寬是多少？
}
這題沒有什麼好說的，祼的最大流問題。 

但最大流問題常常會出的讓你乍看之下不像最大流的題目，
要經過一些轉換或是先得出一些結論後，才能用最大流問題
來解！這也是為什麼最大流問題往往是難題的原因！

比如以下這題
\SampleProblem[經典問題]{不重複路徑數}{ 
  給你一張圖 $G$ ，請找出最多的 $u$ 到 $v$ 的路徑，
  使得這些路徑都不重複。
}
嗯？好像題目裡沒有一個「流」字啊？不過我們可以這樣想，
路徑不能重複，就是每條邊最多只能被走過一次！因此把每個
邊的流量設為 $1$ ，求 $u$ 到 $v$ 的最大流就是答案！

這種把看似不相關的題目轉化成別的題目來求解就是建模。
我們整理一下常見的建模手法。
\begin{enumerate}
  \item 點有容量限制： 我們最大流問題中的流量限制都是在
    邊上而已，無法限制點容量！不過我們可以把每個原來的
    每個點 $v$ 都拆成 $v^+, v^-$，分別連接進來的流量
    和出去的流量，而 $c(v^+, v^-)$ 就設成點的流量上限即可！

  \item 多個源/匯點： 有時候源/匯點不只有一個，這是後可以
    多建一個超級源/匯點，並連一個無限大流量的邊到所有源/匯點。

  \item 無限制流量邊： 通常選一個很大的數，如 $2^{30}$ 等等當
    做容量即可， 只要保證流量永遠不可能達到這個數值，以及這個
    數值不會在計算過程中溢位即可。
\end{enumerate}
我們再來看一些例題。

\SampleProblem[經典問題]{二分圖最大匹配}{ 
  給你一個二分圖，求他的最大匹配。
}
所謂的匹配就是把盡量多的點對配在一起，兩個點可以被配對
若且為若他們有邊相連，而且一個點只能被配到一次。你可以想
像點就代表一些男生女生，有邊相連表示彼此喜歡，你要當月下
老人湊合最多對出來。

經過一翻思考我們可以發現「只能被配到一次」可以用流量 $1$ 來限制
，具體來說假設二分圖的兩個點集是 $V_1, V_2$ ，$V_1$ 裡的所有
的點就從 $s$ 流一條流量為 $1$ 的邊，$V_2$ 裡的點則流一條流量 $1$ 
的邊到 $t$ 。而本來的邊流量上限也全部設成 $1$，求 $s$ 到 $t$ 的最
大流就是答案。

\SampleProblem[經典問題]{混合圖的歐拉回路}{ 
  給你一個連通的混合圖，也就是同時存在有向邊和無向邊的圖，
  問你存不存在一條歐拉回路。
}
要解決這題必須先有一些知識！一個無向圖有沒有歐拉回路的條件大家都會，
就是每個點的度數都要是偶數且連通。 而有向圖的歐拉回路存在的條件也差不多：
\begin{itemize}
  \item 每個點的入度要等於出度，也就是 $\deg^+(v) = \deg^-(v)$。
  \item 所有的點連通。
\end{itemize}
那有向圖呢？其實我們要做的事情就是把所有的無向圖定向，讓整張圖變成有向圖，
並滿足以上兩點的限制。首先我們先定義 $\delta(v) = \deg^-(v) - \deg^+(v)$，
也就是不計算無向邊的情況下，入邊跟出邊的差。我們的目標就是最後要讓 $\forall v, \delta(v) = 0
$。可以這樣想， $\delta(v) > 0$ 的點表示入邊太多了，必須想辦法從無向邊「流
出」 $\delta(v)$ 的量，才可以變成 $\delta(v) = 0$，$\delta(v) < 0$ 亦同，表示
要「流入」$\abs{\delta(v)}$。有沒有發現這個看似與流量無關的題目瞬間與最大流有了聯繫！
我們只需要對於 $\delta(v) > 0$ 的點從 $s$ 建一條流量為 $\delta(v)$ 的邊
\footnote{可能有人會認為是要從 $v$ 建到 $t$ 才對，其實不然，因為這些點必需要
  流出 $\delta(v)$，可以想成我們從 $s$ 強制給了他 $\delta(v)$ 的流，這樣他就必定要
  流出 $\delta(v)$ 了。}
，$\delta(v) < 0$ 的點則建一條到 $t$ 流量為 $-\delta(v)$ 的邊。
而如果 $(u, v)$ 本來有無向邊相連，就建
一條 $(u, v)$ 流量為 $1$ 的無向流量。最後看最大流是不是等於 $\sum_{\delta(v) > 0} \delta(v)$ 
，也就是是否所有的點都被補滿了即可。

\section{最小割模型}
大家應該還記得前面有提到最小割的對偶問題就是最大流，因此有些題目會以最小割的型式出現，
這些題目也可以轉化成最大流來解。比如這個問題

\SampleProblem[UVa 11506]{Angry Programmer}{
  你被你老闆開除了，因此你決定在他打 LOL 的時候讓他斷線。
  從他的電腦 $s$ 到 LOL 伺服器 $t$ 有一些 Router，Router 間有一些
  網路線相連，剪掉 $u$ 到 $v$ 的網路線要花 $c(u, v)$，如
  果 $s$ 到 $t$ 沒辦法經過一些 Router 連到就會斷線，問你要達成計畫
  的最小花費。
}

這個問題其實就是裸的最小割問題，直接轉成最大流來解就可以了。不過當
然，還是有一些經典的建模方式要了解！

\subsection{「分兩類」問題}
這個是最小割最常見的應用！通常題目會要你把點分成兩堆，比如以下這題。

\SampleProblem[經典問題]{生產產品問題}{
  你有 $n$ 個產品可以生產，並且有 $m$ 種不同的機器，生產第 $i$ 個產
  品必須要有一些機器，但不同的產品如果用到相同的機器的話只需要一個
  機器即可，現在給你每個機器的價格，和生產每個產品的獲利，你要決定
  要生產哪些產品使你的獲利最高。
}

其實你要做的事情就是把產品和機器分成兩類，要的和不要的。可以想像每一個
產品和機器都是一個點，現在要把他們分成 $(S, T)$，其中 $S$ 是我們要的，
$T$是我們不要的。有沒有突然有一種 Cut 的感覺了？我們只要讓他的割剛好等
於題目的 cost 就可以了！以下列出一些經典的建模方式。
\begin{enumerate}
  \item 選 $u$ 但不選 $v$ 要花費 $c$：由我們的定義 $u \in S, v \in T$，
    因此由割的定義我們知道只要建 $u \rightarrow v$，流量是 $c$ 的邊即可。
  \item 選 $u$ 就一定要選擇 $v$：其實這只是 1. 的一個特例而已，就是
    選 $u$ 但不選 $v$ 要花費 $\infty$，因此建 $u \rightarrow v$ 流量是 $\infty$ 
    的邊即可。
  \item 選 $u$ 要花費 $c$：這表示 $u \in S$，因此建 $u \rightarrow t$ 流量是
    $c$ 的邊即可。
  \item 選 $u$ 會賺到 $c$：這個比較麻煩，因為沒有負花費，也就是負容量這種東西。
    不過我們可以換個角度想，變成「沒有選到 $u$ 會失去賺 $c$ 的機會」，因此我們
    先把所有選了會賺的點 $u_i$ 都找出來，假設會賺 $c_i$，計算 $C = \sum c_i$，
    表示你全部有機會賺到的量，之後就建 $s \rightarrow u$，流量為 $c$ 的邊，表
    示你一但不選就要失去這個 $c_i$ 了。最後求完最小割在把 $C$ 加上去即可。
\end{enumerate}
剛剛那題的解法就很清楚了，先計算所有產品的總獲益 $C$，對每個產品，依照 4.，建
從 $s$ 流量等於其獲利的邊。再依 3. 對每個機器建一條到 $t$ 流量為其花費的邊。
最後有些產品需要某些機器，也就是「選了這個產品就一定要選一些機器」，由 2.，建
一些無限大的邊即可。

\section{最小花費最大流}
我們將原本的最大流問題做一個推廣，現在每個邊除了有容量限制 $c$ 以外，還有一個
花費 $k(u, v)$ ，表示每單位流量流過要花 $k(u, v)$ 的價格。也就是說對於一個流
$f$，這個流的總花費為
\[ k(f) = \sum k(u, v) \cdot f(u, v) \]
{\bf 最小花費最大流}就是在滿足一個流 $f$ 是圖上的最大流之下，使 $f$ 的花費越小越好。

\subsection{最小花費最大流演算法}

我們先定義一個路徑的花費。
\begin{theorem}[定義]
  一個路徑 $P$ 的花費 $k(P)$ 就是其所有邊的花費總合。
\end{theorem}
與最大流類似，最小花費最大流有以下的性質：
\begin{theorem}[定理]
  一個流 $f$ 是一個最小花費最大流若且唯若其剩餘網路上沒有{\bf 負環}，
  也就是花費為負的環。
\end{theorem}
而且還有一個很重要的性質
\begin{theorem}[定理]
  如果在剩餘網路上沒有負環，現在我們找一個花費最小的路徑擴充，則擴充後
  剩餘網路上還是不會有負環。
\end{theorem}
因此我們就立刻可以得出以下的一個演算法！\\
\begin{algorithm}[H]
  \DontPrintSemicolon
  \caption{Successive shortest path algorithm}\label{euclid}
  \SetKwFunction{FF}{SSP}
  \SetKwFunction{AAP}{AugmentAlongPath}
  \SetKwProg{myalg}{Algorithm}{}{}
  \myalg{\FF{}} {
  \While{We could find an minimum cost augmenting $P$ path from $s$ to $t$}{
    $\Delta f \gets \AAP{P}$ \;
    $f \gets f + \Delta f$ \;
  }
}
\end{algorithm}
至於「找一個花費最小的路徑」，可以用任何最短路演算法來求，但要注意圖上可能會有
負權邊，因此必須要使用能處理負權邊的演算法(如 SPFA 等等)。

而這個演算法的整體複雜度，因為花費最小的路徑顯然不一定是最短 \footnote{這邊指
  邊的數量最少} 的擴充路徑，所以跟 Ford-Fulkerson 一樣，擴充的次數沒有被保證！
在邊權都是整數的情況下複雜度為 $\ord{\mathit{SP} \cdot \abs{f}}$ ，其中
$\ord{\mathit{SP}}$ 是一次最短路演算法的複雜度。

\section{最小花費最大流的應用}
有了求最小花費最大流後，不少原來的題目都可以做一個推擴。
\SampleProblem[經典問題]{二分圖最小花費最大匹配}{ 
  給你一個邊有權值的二分圖，求他的最小花費最大匹配。一個匹配的花費就是
  所有邊的權值的和。
}
這個問題就只是把本來的二分圖最大匹配用最小花費最大流下去做就可以了。這邊就
不在多述。

\SampleProblem[Codeforces 164C]{Machine Programming}{
  你有 $n$ 個工作可以分配給 $k$ 個機器人，每個工作只能給一個機器人做，
  而且第 $i$ 個工作必須從 $s_i$ 做到 $s_i + t_i - 1$ ，不能中斷，做完
  了這個工作可以得到 $c_i$ 元。 問你最多可以賺到多少錢？
}
如果我們把每一天看做是一個點，且每個機器人對應到一單位的流量，那答案就呼之欲出了。
假設每一天對應到 $v_1, v_2, \dots, v_m$ ，那對於工作 $i$ ，我們就建一條 $v_{s_i} \rightarrow 
v_{s_i+t_i-1}$ 的邊，其流量為 $1$ ，也就是只能一個人來做，並且他的花費是 $-c_i$，表示如
果做了這件事情就會賺 $c_i$ 元。之後每一天都建一個無限大流量，花費為 $0$ 的邊到下一天，
表示機器人也可以什麼事都不做到下一天。之後建 $s \rightarrow v_1, v_{m} \rightarrow t$ 
流量各為 $1$ 的邊， 最後求最小花費最大流即可。

\section{額外的問題}
這邊我們在舉一些和最大流有關的一些有趣的問題。

\subsection{最大密度子圖}
\SampleProblem[經典問題]{最大密度子圖}{
給你一個圖 $G = (V, E)$ ，你要求一個 $G$ 的導出子圖 $H = (V', E')$ ，使得他的密度 $\rho = 
\abs{E'} / \abs{V'}$ 最大。
}

通常對於這種要最大化一個分數的問題，第一個直覺就是二分搜答案。假設我們當前猜答案為 $k$ ，
也就是我們變成在問，是否有一個導出子圖滿足
\[ \frac{\abs{E'}}{\abs{V'}} \geq k \quad \Leftrightarrow \quad \abs{E'} \geq k \abs{V'} 
  \quad \Leftrightarrow \quad \abs{E'} - k \abs{V'} \geq 0 \]
這個等價於一個求最大值的問題
\begin{equation}
\max_{H = (V', E')} \abs{E'} - k \abs{V'} \geq 0
\label{eq:dens1}
\end{equation}
注意到
\[ \abs{E'} = \frac{1}{2} \sum_{v \in V'} \deg_H(v)  \]
而
\[ \deg_H(v) = \deg_G(v) - \sum_{\substack{u \notin H \\ (v, u) \in E}} 1 \]
代回 \eqref{eq:dens1} 
\begin{align*}
  \max_{H = (V', E')} \abs{E'} - k \abs{V'} \geq 0 \; & \Leftrightarrow \;
  \max_{H = (V', E')} \sum_{v \in V'} \frac{1}{2} \left( \deg_G(v) -
      \sum_{\substack{u \notin H \\ (v, u) \in E}} 1 \right) - k \\
    & \Leftrightarrow \; - \min_{H = (V', E')} \sum_{v \in V'} \left( \left(2k - \deg_G(v) \right) +
      \sum_{\substack{u \notin H \\ (v, u) \in E}} 1 \right) \\
\end{align*}
有沒有發現這個變成了「分兩類問題」了？ 對於每一個點，選他的 cost 就是 $2k - \deg(v)$ ，
而如果 $(v, u) \in E$，那麼選了 $v$ 卻不選 $v$ 要花額外 $1$ 的 cost。轉化成最小割後用
最大流解即可。

\subsection{最少互斥路徑覆蓋}
\SampleProblem[經典問題]{Minimum disjoint path covering}{
給你一個有向圖 $G = (V, E)$ ，你要用最少不相交的簡單路徑
$P_i$ 把所有的點都蓋過。
一個簡單路徑是一個點都沒有重複的路徑。兩個路徑不相交表示他們
裡面沒有重複的點。
}

一開始想這個問題可能會想把每個路徑對應到一個流。可是我們要
最小化路徑數量，與「最大」流相悖。因此我們換個想法，先想一下
不相交的路徑是什麼意思，其實就是每個點都只能恰屬於一條路徑而已，
而對一個路徑 $v_1, v_2, \cdots, v_n$ 可以發現，每一個元素都有一個
後繼，如 $\mathtt{next}(v_1) = v_2, \mathtt{next}(v_2) = v_3, \dots$，
除了最後一個點以外。因此我們要做的事情其實就是把所有的點「配到」他的
後繼 $\mathtt{next}(v)$，而路徑的數量就是沒有被配到的點數，所以要
最少的路徑就是要匹配最多！現在做法就很明瞭了。對於每個點 $v_i$，構造
$u_i, w_i$，而如果 $(v_i, v_j) \in E$ ，就建造 $u_i \rightarrow v_j$ 的
邊，最後就是要求二分圖的最大匹配！


\section{習題}

  %\setcounter{subsection}{-1}
  %\subsection{Preliminary}
    %\ExerciseProblem[基本知識]{String in C/C++}{
      %俗話說的好，工欲善其事，必先利其器。在學習任何字串演算法前，也要先熟悉C/C++裡的字串操作，不然題目來了還是無從下手！而字串的儲存可以用\texttt{char} Array, 也可以用C++裡的\texttt{std::string}，請熟悉這兩種的各種操作，輸入/出，以及相關的內建函數(如比較函數等等)。並指出下面程式的問題所在。
    %}
    
  \subsection{String Matching}
    \ExerciseProblem[經典問題]{ABA}{
    給定字串$S$，求出最長的$A$使得$S = ABA$。$\cons{\ord{\abs{S}}}$
    }

    \ExerciseProblem[POI XIII]{Periods of Words}{
      給定字串$S$，求出最長的$A$使得 $A$ 是 $S$ 的前綴且 $S$ 是 $AA$ 的前綴。$\cons{\abs{S} \leq 10^6}$
    }

    \ExerciseProblem[POI XII]{Template}{
      給定字串$S$，求出最短的$A$使得 $A$ 可以覆蓋 $S$ 。 比如說 $\str{abaabaab}$ 可以用兩個 $\str{abaab}$ ，分別開頭在 $0, 3$ 蓋住。$\cons{\abs{S} \leq 10^6}$
    }

    \ExerciseProblem[經典問題]{近似匹配}{
      給定字串$A, B$，以及一個整數$k$，求出所有$B$在$A$中$k$幾乎匹配的位置。我們稱$A[i, i+n-1], B[j, j+n-1]$是$k$幾乎匹配如果$\{ A[i+x] \neq B[j+x], \: 0 \leq x \leq n-1 \}$的個數不超過$k$個。 $\cons{\ord{k\abs{A} + \abs{B}}}$
    }

    \ExerciseProblem[TIOJ 1735 / Kelvin]{k-口吃子字串}{
      定義一個$k$-口吃字串為某一個長度為 $k$ 的字串重複兩次的字串。如 $\str{abcabc}, \str{aaaaaa}$ 都是 $3$-口吃字串。給一個字串$S$和 $k$ ，請問有多少 $(i, j)$ 滿足 $S[i, j]$ 是 $k$-口吃字串。  \\
      $\cons{\abs{S} \leq 10^5}$ 
    }

    \ExerciseProblem[經典問題]{KMP and Z value}{
      給你一個字串的 fail function $\fail$ 和他的長度 $n$ (也就是說你並不知道原本的字串) ，請求出他的 Z value $Z$ 。 
      反之亦然，給你一個字串的 Z value $Z$ ，請求出他的 fail function $\fail$ 。 
      $\cons{ \ord{n} }$
    }

    \ExerciseProblem[TIOJ 1725]{Massacre at Camp Happy}{
      定義兩個字串$A, B$是$k$-幾乎相同如果把 $A$ 的前 $k$ 個字元搬到最後面，那兩者恰相差一個字元，給你 $A, B$ ， 求出所有的 $k$ 使得他們是 $k$-幾乎相同。 $\cons{ \abs{A} = \abs{B} \leq 10^6 }$
    }

    \newcommand{\ZZ}{\operatorname{\mathcal{Z}}}
    \ExerciseProblem[經典問題]{最長回文子字串}{
      給一個字串 $A$ ，求出他最長的一個回文子字串。 $ \cons{ \ord{ \abs{A}} }$

      這題可以用類似 Z-algorithm 的方法。我們先考慮如何求最長的{\bf 奇數}回文子字串。 令 $\ZZ(i)$表示以$i$為中心最長的回文字串為 $A[i-\ZZ(i), i+\ZZ(i)]$。 現在假設$(L, R) = (i-\ZZ(m), i+\ZZ(m))$, 即$A[L, R]$是一個以$a[m]$ 為中心的回文。如果 $j \in [m+1, R]$，考慮 $j' = 2m - j$，即$j$對$m$的反射點。現在與Z-algorithm類似，令 $L' = j - \ZZ(j')$，分別考慮 $L' > L, L' = L , L' < L$ 三種情況。

      但此方法僅能求得奇數的回文長度。因此我們把原字串相鄰的兩個字元都插入一個不在字元集 $\Sigma$ 中的字元，如 $A = \str{abbab} \; \rightarrow A' = 
  \str{a\$b\$b\$a\$b}$，這樣所有回文的長度都變成奇數了。
    }

    \ExerciseProblem[Codeforces Zlobober's blog]{Anti-hash text}{
      在 Hashing 實作上，因為 C++ 的模運算 \texttt{\%} 是非常花時間的，因此有一種 Lazy hash 的方法是 直接 $\bmod{2^{32}}$ 或是 $\bmod{2^{64}}$，這樣直接在 $\texttt{int}, \texttt{long long}$ 下做運算就可以了。但這樣做有其風險在，以下說明其原因。

      不妨假設此 Hash function 為
      \[ f(A) = \sum_{i=0}^{n-1} a_i p^{n-1-i} \bmod{q} \]
      其中 $p$ 為一奇數(否則此 Hash function 無意義)，$q = 2^m$，並且 $\str{a}, \str{b}$ 轉換成數字後分別為 $\alpha, \alpha + 1$ 。此時令
      \[ A_0 = \str{a}, \quad A_j = \widetilde{A}_{j-1} A_{j-1} \]
      其中 $\widetilde{A}$ 表示把字串 $A$ 中的 $\str{a}$ 換成 $\str{b}$， $\str{b}$ 換成 $\str{a}$。如：
      \[ A_1 = \str{ba}, \quad A_2 = \str{abba}, \quad A_3 = \str{baababba}, \quad \cdots \]
      現在考慮 $A_{k}, \widetilde{A}_{k}$，注意這兩個字串恰好是 $A_{k+1}$ 的前後半且 $A_k \neq \widetilde{A}_{k}$。請證明
      \begin{align*}
        f(\widetilde{A}_{k}) - f(A_{k}) &= p^0 - p^1 - p^2 + p^3 -p^4 + p^5 + \cdots + (-1)^{k-1} p^{2^{k}-1} \\
        &= \sum_{i=0}^{2^{k}-1} b_i p^i  \quad = S
      \end{align*}
      其中 $b_i \in \{ 1, -1 \}$，且如果 $i$ 的二進位表示有偶數個 $1$ ，則 $b_i = 1$，否則 $b_i = 0$。並且有
      \[ \sum_{i=0}^{2^{k}-1} b_i p^i = (p-1)(p^2-1)(p^4-1) \cdots (p^{2^{k-1}} - 1) \]
      注意到 $(p^{2^r} - 1)$ 可以被 $2^{r+1}$ 整除 (Why?) ，所以 $S$ 可以被 $2^{1 + 2 + \cdots + k} = 2^{k (k+1)/2}$整除。因此只要 $2^{k(k+1)/2}$ 被 $2^m$ 整除，也就是$\frac{k(k+1)}{2} > m$，$A_{k}$ 和 $\widetilde{A}_{k}$ 的 Hash value 就會相同。因此可以用一個長度為 $2^{\ord{x}}$ 的字串構造出一個使 $q = 2^{\ord{x^2}}$ 的 Hash function 失效的反例，並且與 $p$ 的選擇無關。
    } 

    \ExerciseProblem[經典問題]{二維匹配}{
      給你一個 $R_A \times C_A$ 的二維字串 $A$ ， 問一個 $R_B \times C_B$ 的二維字串 $B$ 有沒有出現在其中？ $\cons{ \ord{ R_A C_A + R_B C_B }}$。

      一個巧妙的做法可參考 Baker-Bird Algorithm，令外也有用 Hash 的方法，令$c = C_B, \; a_i[j] = f(A[i][j, j+c-1])$，原題等價於問 $f(B[0]), f(B[1]), \cdots f(B[R_B-1])$ 是不是等於\\ 
      $a_i[j], a_{i+1}[j], \cdots , a_{i+R_B-1}[j]$。這是一個一維的匹配問題。詳細可參考去年的講義。
    }

    \ExerciseProblem[ACM ICPC 2013-2014 NEERC Northern Subregional]{sed}{
      給你$A, B$，求出字串 $X, Y$ 使得將 $A$ 中的 $X$ 取代為 $Y$ 後會變成 $B$，並且 $\abs{X} + \abs{Y}$ 最短。 取代的定義為找 $X$ 出現在 $A$ 的第一個位置，假設 $A[i, j] = X$ ，立刻將 $A[i, j]$ 變成 $Y$ ，並從 $j+1$ 繼續找下一個 $X$ 直到沒有為止。 $\cons{ \abs{A}, \abs{B} \leq 5000}$。
    }

  \subsection{Suffix structure}
    \ExerciseProblem[經典問題]{最小的後綴}{
      給一個字串 $A$ ，求出他字典序最小的後綴。 $\cons{\ord{\abs{A}}}$

      有不需要建出Suffix Array的方法。 \footnote{Hint: 雙指針}

      這有一些應用，如最小循環表示法。 有時候我們會把一個狀態或物體用一個字串表示，並且可能旋轉需視為相同的，也就是把字串前 $k$ 個字元接到後面視為相同。 這時候如果要比較兩個字串，可以先求他們的最小循環表示在進行比較。
    }

    \ExerciseProblem[經典問題]{重複子字串}{
      給一個字串 $A$ ，求出他最長的一個重複的子字串，重複的部分可以重疊。比如說 $A = \str{cabababc}$，最長的重複子字串為 $\str{aba}$。 $ \cons{ \ord{ \sa } }$ \footnote{ $\ord{ \sa }$ 表示建出後綴數組所需的時間。} \\
      如果改成不能重複呢？ $\cons{ \ord{ \abs{A} \log \abs{A} } }$
    }

    \ExerciseProblem[經典問題]{連續重複的子字串}{
      給一個字串 $A$ ，求出他的連續重複次數最多的子字串。比如說 $A = \str{cababababc}$， $\str{ab}$在子字串$\str{abababab}$中連續重複了$4$次。
    } $\cons{ \ord{ \abs{A} \log \abs{A} } }$

    \ExerciseProblem[ASC 40]{Binary Suffix Array}{
      給定一個 $n$ 個整數的序列 $a_1, a_2, \cdots, a_n$， 找出一個01字串 $A$ 使得 $A$ 的後綴數組 $\sa$
      恰好是給定的序列，注意到有可能無解。
    } $\cons{ \abs{A} \leq 3 \cdot 10^5}$

    \ExerciseProblem[SPOJ 7258]{Lexicographical Substring Search}{
      給一個字串 $A$ ，現在把 $A$ 的所有子字串列出，將重複的刪去後排序。對於 $Q$ 比詢問， 輸出字典序第 $k$ 小的子字串。
    } $\cons{ \abs{A} \leq 90000, Q \leq 500}$

    \ExerciseProblem[NTUOJ 2200]{Beautiful Substring}{
      給一個字串 $A$ ， 把他所有不同的子字串找出來，令這個集合為 $S$ ，接著每次會給一個字串 $B_i$， 假設他所有不同的子字串的集合為 $T_i$， 就令 $S \leftarrow S \setminus T_i$，並輸出此時的 $\abs{S}$，也就是 $S$ 裡還剩多少字串。
    } $\cons{ \abs{A} \leq 2 \times 10^5,\; \sum \abs{B_i} \leq 10^6}$

    \ExerciseProblem[ASC 42]{Incomparable Suffixes}{
      給一個字串 $A$ ， 我們說兩個字串 $s, t$ 是{\bf 可分辨的} 若且為若存在一個字串 $z$ 使得 $sz, tz$ 中恰好只有一個是
      $A$ 的後綴， 說兩個字串 $s, t$ 是 {\bf 無可比較的} 若且為若對所有 $s$ 的前綴 $x$ ， $t$ 的前綴 $y$ ， 
      $x, y$ 都是可分辨的。 現在請找出 $a_1, a_2, \cdots, a_n$ 滿足：
      \begin{enumerate}
        \item 所有 $a_i$ 都是 $A$ 的後綴。
        \item $n$ 越大越好。
        \item 在 $n$ 是所有可能的最大值下， $\sum \abs{a_i}$ 越大越好。
      \end{enumerate}
    } $\cons{ \abs{A} \leq 10^5}$
  \section{Special Thanks}
  此分講義部分參考自前年的講義，特別感謝前年的編輯者。
\end{document}
