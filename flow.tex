%\documentclass[main.tex]{subfiles}
\documentclass[a4paper,12pt]{book}
\input{npsc.tex}  % by little fish (will be the deprecated doc-style)
\input{ioicamp.tex}  % modifications for ioicamp
\usepackage{caption}
\DeclareCaptionLabelFormat{cfig}{圖#2}
\captionsetup{labelformat=cfig}


\begin{document}


\newcommand{\str}[1]{\texttt{"#1"}}
\newcommand{\mcstr}[2]{\texttt{"#1}\cdots\texttt{#2"}}
\newcommand{\ord}[1]{\opord\left(#1\right)}
\newcommand{\abs}[1]{\lvert #1 \rvert}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\ceil}[1]{\lceil #1 \rceil}
\newcommand{\opord}{\operatorname{\mathcal{O}}}
\newcommand{\fail}{\operatorname{\mathcal{F}}}
\newcommand{\flk}{\operatorname{\mathfrak{F}}}
\newcommand{\suf}{\operatorname{\sigma}}
\newcommand{\rank}{\operatorname{\mathcal{R}}}
\newcommand{\sa}{\operatorname{\mathcal{SA}}}
\newcommand{\hei}{\operatorname{\mathcal{H}}}
\newcommand{\edps}{\operatorname{\mathcal{E}}}
\newcommand{\mx}{\operatorname{\mathcal{M}}}
\newcommand{\argmax}{\operatorname{arg\,max}}
\newcommand{\cons}[1]{\left[ \: #1 \: \right]}

\newcommand\numbereqn{\addtocounter{equation}{1}\tag{\theequation}}
\newcommand\listeqn{\hfill\refstepcounter{equation}(\theequation)}
\newenvironment{monobox}{\linespread{0.6}\Verbatim[frame=single, commandchars=\\\{\}]}{\endVerbatim}
\makeatletter

\NewChapter{流}{Flow} 

\begin{comment}
  # Definition
  # Maximum s-t Flow algorithms
  # Models
  # Minimum Cost Maximum Flow algorithms
  # Models
  # Feasible flow
  # Models
  # Advanced topic and misc
\end{comment}

網路流與我們生活中的一些問題息息相關， 比如我們要從一工作站 $s$ 傳輸一個資料
到工作站 $t$ ，傳輸的過程有一些中繼站， 並且某些中繼站間和某些中繼站到工作站
間有傳輸率為 $c$ 的網路線相通，現在要如何找出一個最佳的傳輸方案，使得 $s$ 
到 $t$ 的資料傳輸速率最快？ 

以上就是網路流問題的原型，但隨後人們驚訝的發現網路流還可以用以解決一些看似
無關的問題！如匹配問題、歐拉回路問題等等。網路流的問題千變萬化，常常令人
異想不到，也因此常成為程式競賽的難題，如果能精熟這個領域，便如有了一把解題
的利刃！

\section{前言}

首先我們定義何謂網路流。

\begin{theorem}[定義]
  一個{\bf s-t 網路流}是一張圖(有向或無向) $G = (V, E)$ ， 每條邊上有一個非負的權重
  $c(u, v) \geq 0$ 代表邊的{\bf 流量上限}(如果 $(u, v) \notin E$ 我們定義 $c(u, v) = 0$)。 
  並且有二個特別的點， 源點 $s$ 與 匯點 $t$ 。

  一個{\bf s-t 可行流} 是一個函數 $f : V \times V \mapsto \mathbb{R}$ 滿足以下兩個條件
  \begin{itemize}
    \item \makebox[7cm]{$f(u, v) \leq c(u, v), \; \forall (u, v) \in V \times V$\hfill}
      (流量限制)  \listeqn \label{def:flow1}
    \item \makebox[7cm]{$f(u, v) = -f(v, u), \; \forall (u, v) \in V \times V$ \quad} 
      (流量對稱) \listeqn \label{def:flow1}
    \item \makebox[7cm]{對於所有 $v \in V$ ， 有 $ \sum\limits_{u \in V} f(v, u) = 0 $ \quad} 
      (流量守衡) \listeqn \label{def:flow1}
  \end{itemize}

  而我們定義這個 s-t 流的{\bf 流量}為 \[ \abs{f} = \sum_{v \in V} f(s, v) \]
\end{theorem}

換句話說，我們必須給出每一條邊應往哪個方向流、流多少。 當然，不是隨隨便便流都可以的，
必須滿足這三個限制！

\begin{enumerate}[label=(1.\arabic*) :]
  \item 每條邊的流量都沒有超過他的限制。
  \item 如果 $u$ 往 $v$ 流 $c$ 單位就相當於 $v$ 往 $u$ 流 $-c$ 單位。
  \item 流不能無中生有！ 每一點除了 $s, t$ 以外進去的流量要等於出去的流量，也就是
    淨流量必須是 $0$ 。
\end{enumerate}


\tikzset{vertex/.style={circle, draw, thick, minimum size=.8cm}}
\tikzset{source/.style={vertex, fill=black!20}}
\tikzset{fed/.style={draw, -latex, thick}}
\tikzset{%
  apply style/.code={%
    \tikzset{#1}%
  }
}
\begin{figure}[H]
  \centering
  \input{tikz/flow1.tex}
  \caption{一個流量網路的例子}
  \label{fig:flow1}
\end{figure}

如圖~\ref{fig:flow1} 就是一個流量網路的例子，而右圖則是他的一組解。
讀者可以驗證這個解的確滿足 s-t 可行流的三個限制。

而通常我們會希望流量 $\abs{f}$ 可以越大越好， $\abs{f}$ 最大的
s-t 可行流就稱作{\bf 最大流}。

\section{最大流演算法}
我們定義了最大流後，現在的問題是要如何找出一個最大流以及他的流量呢？

\begin{theorem}[定義]
  給定一個字串$A = a_0 a_1 \cdots a_{n-1}$
\begin{itemize}
  \item 一個\emph{子字串}是其連續的一段$a_i a_{i+1} a_{i+2} \cdots a_j$ 記作$A[i,j]$。
\item 一個\emph{子序列}是一個字串$B = a_{q_1} a_{q_2} a_{q_3} \cdots a_{q_m}$，其中$0 \leq q_1 < q_2 < q_3 < \cdots < q_{m-1} < q_m < n$ 。
\item 一個$A$的\emph{前綴}是$A$的一個子字串$a_0 a_1 a_2 \cdots a_{h}$，其中$0 \leq h < n$，記作$P_A(h)$。
\item 一個$A$的\emph{後綴}是$A$的一個子字串$a_k a_{k+1} a_{k+2} \cdots a_n$，其中$0 \leq k < n$，我們特別記作$S_A(k)$。並讓所有後綴的集合稱作$\suf(A)$。
\end{itemize}
\end{theorem}
舉例來說，如果$A = \str{abcbbab}$，那\str{bcb}是他的子字串，\str{acb}是他的子序列，而\str{bbab}是他的一個後綴。

\section{字串的儲存}
通常最基本的儲存方式就是用一個陣列依序將字串的每一個字元存下來。不過當我們要同時儲存許多字串時，可能就要花點巧思了。而這邊要介紹一個可以同時儲存多個字串的資料結構─{\bf  字典樹 Trie}。\\
Trie的道理非常簡單，其實就是用一棵樹來儲存字串。在這棵樹上，每個點(除了根節點之外)上都有一個字元，而從根節點一路走到某個節點，依序經過的字元串起來就是那個點代表的字串。最後我們再記錄哪些點是一個字串的最後一個字元即可！
如Figure~\ref{fig:trie}就是一個儲存$\{A_1 = \str{abc}, A_2 =\str{abde}, A_3 = \str{bc}, A_4 = \str{bcd}\}$的trie
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    [every node/.style = {draw, circle, minimum size = 1cm}
    ,edge from parent/.style = {draw, -latex, thick}
    ,level distance = 20mm
    ,endn/.style = {thick, double=gray!20, double distance = 2pt, fill=gray!20}]
    \node{\char`\^}[grow=east] {
      child{node {a} 
        child{node {b} 
          child{node[endn]{c}}
          child{node{d}
            child{node[endn]{e}}
          }
        }
      }
      child{node{b}[]
        child{node[endn]{c}[grow=north east]
          child{node[endn]{d}}
        }
      }
    }
    ;
  \end{tikzpicture}
  \caption{An example of trie}
  \label{fig:trie}
\end{figure}
%
\begin{theorem}[定義]
  給定一個字典樹Trie \  $T = \{V, E\}$，我們定義$P_T(v)$為從根節點走到$v$所得出的字串。
\end{theorem}
而Trie的基本操作也都很簡單，如要新增一個字串$A$，我們就從根節點開始，依照字串$A$的第$0, 1, 2, \cdots, n-1$個字元，如果此字元在當前節點的子節點中就繼續走下去，否則就新增一個節點。

\section{字串匹配}
  字串匹配是一個生活中一定會遇到的問題。當你要從一篇滿滿文字的網頁或是pdf檔找關鍵字時，相信大家一定會本能的按下ctrl-f，接著一瞬間，電腦就會自動算好所有蒐尋字串出現的位置。看似簡單，嘿嘿！其實裡面可是有大學問的呢。

\SampleProblem[Everywhere]{String Matching}{ 給你兩個字串 $A$, $B$ 找出所有 $B$ 出現在 $A$ 中的位置。}

而一般大家最先想到的做法通常是…就把所有的位置試過一遍！ 

這樣寫好不好呢？其實可以證明這樣的{\bf 期望複雜度}是$\ord{\abs{A}}$。可惜的是，最差的情況可以到$\ord{\abs{A}\abs{B}}$！更糟的是很容易構造出例子，如$A = \mcstr{AAAAA}{AA}, B = \mcstr{AAA}{B}$，這樣雖然$B$從來沒有出現在$A$中，但是每個位置我們都必需匹配到$B$的最後一個字元才能確定匹配失敗！
那要怎麼改進這個演算法呢？著手點有兩個：
\begin{enumerate}
  \item 事前處理：我們剛剛一拿到兩個字串便埋頭苦幹，但如果我們能先對這兩個字串做點觀察、處理，或許能得到一些有用的資訊。
  \item 善用已知的資訊：在匹配的過程中，或許我們也可以得到一些訊息！顯然這個做法並沒有妥善利用！
\end{enumerate}
\section{Hashing}
想想看你要在茫茫人群中找你的同學，通常會怎麼找呢？不外乎是先看衣服顏色，髮形之類的。沒錯！如果我們可以把東西加以分類，便可加速蒐尋速度！但當然，分類也是有技巧的，就像你不會用"正立/倒立走路"或是"指紋圖形"來分類路人，因為前者沒有多少人是用倒立走路的吧，而後者雖然極精確，但也太花時間了！\\
在字串上也是相同的道理，總而言之我們想做的事情是：
\begin{enumerate}
  \item 找到一個分類函數，即是一個$f: \mathbb{S}(\Sigma) \mapsto \mathbb{Z}$，把所有可能的字串打到有界的整數，不妨說$f(s) \in [0, M-1] \; \forall s$吧！
  \item 這個函數最好是均勻分部在$[0, M-1]$上。
  \item 計算這個函數最好不需花太多時間！
\end{enumerate}
\begin{theorem}[定義]
  一個滿足以上條件的函數我們就稱作\emph{Hash function}
\end{theorem}
有了Hash function後有什麼用呢？有的！雖然我們{\bf 無法保證$A \neq B \; \Rightarrow f(A) \neq f(B)$}，因為$f$把有無窮多個元素的字串集合打到有限個整數上，當然會有許多字串被打到同一個整數！但至少我們會知道
\[
  f(A) \neq f(B) \quad \Rightarrow \quad A \neq B
\]
也就是說如果兩個字串的Hash value不一樣，那我們連匹配都不需要了，他們鐵定不相等！
至於Hash function要怎麼找呢？一個常用的方法如下
\begin{theorem}[Rabin-Karp rolling hash function]
  給定$p, q$，令
  \begin{align*}
    f(A) &= a_0 p^{n-1} + a_1 p^{n-2} + \cdots + a_{n-2} p + a_{n-1} \mod{q}\\
         &= \sum_{0}^{n-1} a_i p^{n-i-1} \mod{q} \numbereqn \label{rol}
  \end{align*}
\end{theorem}
看起來很複雜，其實就是字串$A$在$p$進位制代表的值模$q$而已！那這個函數有符合我們的需求嗎？首先他把每個字串打到$[0, q-1]$，可以想成他把所有字串分成$q$類。另外數學家跟我們說，如果$p,q$取兩個不同的質數，通常結果會不錯，非常均勻\footnote{可以參考習題1-8}！另外計算這個函數只需要$\ord{|A|}$，並且他還有一個很好的性質！
\begin{theorem}[Sliding Window]
  假設$f$由\eqref{rol}給出，則
  \begin{equation}
    \label{sld1}
    f(A) \equiv f(A[0, n-2]) p + a_{n-1} \pmod{q}
  \end{equation}
  並且
  \begin{equation}
    \label{sld2}
    f(A[i, j]) \equiv f(A[0, j]) - p^{j-i+1} f(A[0, i-1]) \pmod{q}
  \end{equation}
\end{theorem}
這些都可以由\eqref{rol}計算得出。\eqref{sld1}告訴了我們計算字串$A$所有前綴的hash value可以在$\ord{\abs{A}}$的時間用遞迴求出！仔細看\eqref{sld2}可以發現如果知道了$A$所有前綴的hash value，任何$A$的子字串的hash value都可以在$\ord{1}$的時間計算出來\footnote{真的嗎？$p^{j-i+1}$怎麼辦？}！ \\
回到我們字串匹配的問題，相信大家都看出來了，我們只需要事先算出$A$所有前綴的hash value和$f(B)$，再枚舉$A$所有長度為$\abs{B}$的子字串(差不多$\ord{A}$個)，最後計算這些子字串的hash value是不是等於$f(B)$，總共只需要$\ord{N}$…
等等！回想我們剛剛說的：我們知道$f(A) \neq f(B) \Rightarrow A \neq B$，但卻無法保證$f(A) = f(B) \Rightarrow A = B$啊？有人可能會想說："相等時重新檢查一次"，但如果$A = \mcstr{AAA}{AAA}, B = \mcstr{AA}{AA}$，完蛋了！又退化成$\ord{\abs{A} \abs{B}}$了！ \\
那怎麼辦呢？答案是：把$q$取大一點，然後就假設$f(A) = f(B)$的機率很小，不會發生！事實上如果$f$是均勻的，那$f(A) = k$的機率差不多是$1/q$！只要$q$取夠大，比如一個\texttt{long long}的質數，差不多$10^{15}$，那麼兩個不同的字串{\bf 碰撞}的機率是$10^{-15}$，是一個人被閃電打到兩次的機率\footnote{機率一次差不多是$8 \times 10^{-7}$}，不太可能啦！

\section{KMP}
剛剛說的Hashing method畢竟還是一個機率演算法，而且模運算是很花時間的！因此這邊要講一個很厲害的演算法，Knuth–Morris–Pratt algorithm！ \\
我們先回到一開始naive matching失敗的例子，$A = \str{aabaabaac}, B = \str{aabaac}$，我們第一次的匹配如下，在$5$的位置匹配失敗。

    \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}
        \node at (-0.5, 1.3) {$ i = $};
        \node at (-0.5, .5) {$ A = $};
        \foreach \c [count=\x from 0] in {a,a,b,a,a,b,?,?} {
          \ifthenelse{\x = 5}
          { \draw[fill=gray!80] (\x, 0) rectangle ++(1, 1) }
          { 
            \ifthenelse{\x > 5}
            { \draw[fill=gray!0] (\x, 0) rectangle ++(1, 1) }
            { \draw[fill=gray!30] (\x, 0) rectangle ++(1, 1) }
          }
          node[midway] {\large \c} 
          node[midway, yshift=0.8cm] {\x};
        }
        \node at (8.5, 0.5) {$\cdots$} ;

        \node at (-0.5, -.8) {$ B = $};
        \node at (-0.5, -1.6) {$ j = $};
        \foreach \c [count=\x from 0] in {a,a,b,a,a,c} {
          \ifthenelse{\x = 5}
          { \draw[fill=gray!80] (\x, -1.3) rectangle ++(1, 1) }
          { \draw[fill=gray!30] (\x, -1.3) rectangle ++(1, 1) }
            node[midway] {\large \c} 
            node[midway, yshift=-0.8cm] {\x};
        }

      \end{tikzpicture}
    \end{center}
    \caption{}
    \label{fig:}
    \end{figure}

那些$A$還沒被匹配過的地方我們用? 表示。現在如果我們用最原始的方法，我們必須將$B$右移一格繼續匹配，重新來過。但仔細觀察就會發現

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node at (-0.5, 1.3) {$ i = $};
    \node at (-0.5, .5) {$ A = $};
    \foreach \c [count=\x from 0] in {a,a,b,a,a,b,?,?} {
      \ifthenelse{\x = 5}
      { \draw[fill=gray!30] (\x, 0) rectangle ++(1, 1) }
      { 
        \ifthenelse{\x > 5}
        { \draw[fill=gray!0] (\x, 0) rectangle ++(1, 1) }
        { \draw[fill=gray!30] (\x, 0) rectangle ++(1, 1) }
      }
      node[midway] {\large \c} 
      node[midway, yshift=0.8cm] {\x};
    }
    \node at (8.5, 0.5) {$\cdots$} ;

    \foreach \c [count=\x from 0] in {a,a,b,a,a,c} {
      \ifthenelse{\x = 0}
      { \draw[fill=gray!30] (\x, -1.3) ++ (1, 0) rectangle ++(1, 1) }
      { \ifthenelse{\x = 1} 
        { \draw[fill=gray!80] (\x, -1.3) ++ (1, 0) rectangle ++(1, 1) }
        { \draw[fill=gray!0] (\x, -1.3) ++ (1, 0) rectangle ++(1, 1) }
      }
        node[midway] {\large \c} ;
    }

    \foreach \c [count=\x from 0] in {a,a,b,a,a,c} {
      \ifthenelse{\x = -1}
      { \draw[fill=gray!30] (\x, -2.5) ++ (2, 0) rectangle ++(1, 1) }
      { \ifthenelse{\x = 0} 
        { \draw[fill=gray!80] (\x, -2.5) ++ (2, 0) rectangle ++(1, 1) }
        { \draw[fill=gray!0] (\x, -2.5) ++ (2, 0) rectangle ++(1, 1) }
      }
        node[midway] {\large \c} ;
    }

    \foreach \c [count=\x from 0] in {a,a,b,a,a,c} {
      \ifthenelse{\x < 3}
      { \draw[fill=gray!30] (\x, -3.7) ++ (3, 0) rectangle ++(1, 1) }
      { \ifthenelse{\x = 3} 
        { \draw[fill=gray!50] (\x, -3.7) ++ (3, 0) rectangle ++(1, 1) }
        { \draw[fill=gray!0] (\x, -3.7) ++ (3, 0) rectangle ++(1, 1) }
      }
        node[midway] {\large \c} ;
    }

  \end{tikzpicture}
\caption{}
\label{fig:}
\end{figure}

右移$1, 2$格分別在$1, 0$的位置就匹配失敗了。注意到這兩個位置都對應到$A[2]$，而$A[2]$是我們早就匹配過的！也就是說這個"失敗"是我們應該要知道的。更甚者，這整件事情只跟$B$本身有關！因為我們早以確認過$A[0, 4] = B[0, 4]$。換句話說，對於一個字串$B$，不論$A$是多少，我們早就可以知道某些$(j, s)$，代表"如果我們在$B[j+1]$的位置匹配失敗後，往前$s$格繼續匹配"這件事情，是完全不必要的！\\
那到底在$B[j+1]$匹配失敗時，我們該往右移幾格呢？根據我們上面的討論，如果我們已經匹配了$A[i, i+j] = B[0, j]$，現在將$B$右移$s$格，那麼至少$A[i+s, i+j] = B[0, j-s]$，也就是
\[ B[0, j-s] = A[i+s, i+j] = B[s, j] \]
因此我們應該要找第一個(最小的)$s$滿足上式，也就是最大的$j-s$。這就是我們要定義的KMP裡一個非常重要的函數─失敗函數$\fail(j)$。

\begin{theorem}[定義(Fail function)]
  對於一個字串$B = b_0 b_1 \cdots b_{m-1}$，我們定義
  \[
    \fail_B(i) = 
    \begin{dcases}
      \max \{ k: P_B(k) = B[0, k] = B[i-k, i] \} & \text{if } i \neq 0 \text{ and at least a $k$ exists}\\
      -1 & \text{else}\\
    \end{dcases}
  \]
  $\fail(i)+1$也稱作在第$i$個位置的\emph{共同前後綴}長度
\end{theorem}

由上面的推論，我們總結$\fail(j)$的一個非常重要的性質：{\bf $\fail_{B}(j)$告訴我們在拿$B$去匹配$A$的過程中，如果$B[0, j]$已經匹配成功，但在第$j+1$個位置匹配失敗了，應該要把$B$的第$\fail(j)$個字元對齊原本$B[j]$的位置繼續匹配}！舉個例子，容易知道如果$B = \str{aabaabd}$，則 $ \{\fail(j)\} = \{-1, 0, -1, 0, 1, 2, -1\}$，假設我們已經匹配$B[0,4]$，但在第$5$個字元出問題了，
\begin{monobox}
01234567
A = aabaaa?????
    |||||*        Matching failed at position 5
B = aabaabd         
       ||*        F(4) = 1, Matching failed at position 2
       aabaabd
        |*        F(1) = 0
        aabaabd
\end{monobox}
這樣我們一次可能往前一大步，而不用每次位移一格重新匹配了！\\
現在只剩一個問題了，要怎麼求失敗函數呢？其實很簡單，假設我們已經求出了\\
$\fail(i), \forall 0 \leq i \leq n$，現在要求$\fail(n+1)$，根據定義相當於要求最大的$k = k'+1$使$B[0, k] = B[n+1-k, n+1]$。而
\[
  B[0, k] = B[n+1-k, n+1] \; \Leftrightarrow \; B[0, k'] = B[n-k', n] \land B[k'+1] = B[n+1]
\]
由失敗函數的定義我們知道$k'$最大只能是$\fail(n)$，如果此時$B[\fail(n)+1] = B[n+1]$我們立刻便知道$\fail(n+1) = \fail(n) + 1$。但如果不是怎麼辦？難道必需 $k' = \fail(n)-1 , \fail(n)-2\cdots, 0$ 一直試下去嗎？不要忘記我們已經算出所有 $n$ 以下的 $\fail(i)$ 了，而 $\fail(j)$ 告訴我們在$B$匹配$A$的過程中，如果
\[ A[i, i+j] = B[0, j] \; \land \; A[i+j+1] \neq B[j+1] \]
我們應該把$B$的第$\fail(j)$個字元對齊原本$B[j]$的位置繼續匹配，令$A = B, i = n - \fail(n), j = \fail(n) \leq n$，上式變成
\[ B[n - \fail(n), n] = B[0, \fail(n)] \; \land \; B[n+1] \neq B[\fail(n)+1] \]
這不恰恰是我們現在的情況嗎？因此由 $\fail(j) = \fail(\fail(n))$ ，我們便把當前位置($n$)對齊 $B[\fail(\fail(n))]$。也就是下一個要試的$k'$是$\fail(\fail(n))$！如果又失敗，我們便再試$\fail^3(n), \fail^4(n) \cdots$，直到終於成功或是確認沒有$k$存在($\fail(n+1) = -1$)。這正是失敗函數的精髓！他告訴我們一旦失敗該何去何從。\\
這邊附上一個KMP的範例程式碼，並總結一下KMP的性質。


\begin{theorem}[定理]
  對於一個字串$B$，有
  \begin{itemize}
    \item $B[0, \fail(i)]$是$B$最長的一個前綴使得$B[0, \fail(i)] = B[i - \fail(i), i]$但$\fail(i) \neq i$
    \item 令$\fail^k(i) = \overbrace{f \circ f \circ \cdots \circ f}^{k} (i)$，則：
      \begin{itemize}
        \item $\exists n, \; \fail^n(i) = -1$
        \item $ \fail^{k+1}(i) < \fail^{k}(i) \quad \text{if} \quad \fail^k(i) \neq -1 $ \listeqn \label{fail2}
        \item 令$K = \{ i, \fail(i), \fail^2(i) , \cdots , \fail^{n-1}(i), \fail^n(i) = -1\}$，則\\$B[0, k] = B[i-k, i] \; \Leftrightarrow \; k \in K$ \listeqn
      \end{itemize}
    \item $-1 \leq \fail(i+1) \leq \fail(i) + 1$ \listeqn
  \end{itemize}
\end{theorem}

最後我們分析一下KMP的時間複雜度，參考範例程式碼，可以發現不管在計算$\fail$或是在匹配，對於每一次的匹配，當前$B$的匹配位置(current\_pos)會
\begin{enumerate}[(a)]
  \item 被疊代入$\fail$若干次。
  \item 如果匹配成功，便加$1$。
\end{enumerate}
但因為\eqref{fail2}，我們知道每次疊代current\_pos至少會減$1$，並且疊代到$-1$時便會停止，因此(a)中疊代的次數不會超過(b)被執行的次數！而(b)又不會超過字串的長度，所以KMP的時間複雜度是$\ord{\abs{A} + \abs{B}}$，線性！

\section{Aho–Corasick Algorithm*}
  Aho-Corasick Algorithm 可以說是 KMP 的強化板。如果今天我們要在字串$A$上搜尋很多字串$B_1, B_2, \cdots B_n$要怎麼做？當然我們可以做$n$次KMP得到一個$\ord{n\abs{A} + \sum\abs{B}}$的方法，但信不信由你，其實我們可以在$\ord{\abs{A} + \sum \abs{B}}$的時間完成！ \\
%
  KMP在進行字串匹配之前必需要計算失敗函數，與此類似，Aho-Corasick Algorithm要先造出一個AC自動機，聽起來很炫，好像是可以自動幫我們AC題目的機器，其實應該只是Aho-Corasick的縮寫而已啦！ \\

  還記得KMP的Fail function $\fail$嗎？其實我們可以想像Fail function 是一堆指針，告訴我們匹配失敗時要回到哪裡。現在我們要推廣到多個匹配字串呢？首先我們要把所有的匹配字串建成一棵{\bf 字典樹Trie}，
  此時你會發現，匹配的過程其實就是在Trie上面移動！假設我們已經在點 $v$ ，如果下一個字元 $A[i+1]$ 存在於 $v$ 的子節點中，那我們就繼續往下走。
  現在和單字串匹配其時一模一樣！我們現在只需要克服那一個共同的問題即可，當匹配失敗時，也就是 $A[i+1]$ 不在 $v$ 的子節點中，如何避免回到根節點全部重新來過？ 回憶一下 $\fail(j)$ 的定義 
  \[ B[0, \fail(j)] = P_B(\fail(j)) = B[j-\fail(j), j], \quad \text{且 }\fail(j) \text{ 最大}\]
  也就是說$P_B(\fail(j))$要是$B[0, j]$的後綴 \footnote{回憶一下$\fail(i)+1$也是{\bf 最長共同前後綴}長度}
  。那在字典樹上，我們理所當然應該修正為以下的定義

\begin{theorem}[定義]
  對於一個字典樹$T = \{V, E\}$，其中$v_0$為他的根節點，對$v \in V$我們定義
  \[
    \flk(v) = 
    \begin{dcases}
      u & \text{if } P_T(u) \text{ 是 }P_T(v)\text{ 的一個後綴且 }\abs{S_T(u)}\text{最大} \\ 
    v_0 & \text{else}
    \end{dcases}
  \]
\end{theorem}
記得$P_T(v)$ 我們定義成從根節點走到$v$的字串。
這樣與KMP時一樣，我們匹配失敗時就沿著$\flk(v)$往下走，直到可以繼續匹配下去或是回到了根節點了。\\
現在唯一的問題只剩下如何建出$\flk(v)$了。觀察後可發現
\[
  u = \flk(v) \quad \Rightarrow \quad \abs{S_T(u)} < \abs{S_T(v)}
\]
因此我們可以以BFS的順序，逐一建出這個表！
與KMP相似，匹配時若失敗便往$\flk(v)$走，直到走到根節點或是終於匹配成功為止。

\section{Z Algorithm}
  在計算一個答案時，如果能妥善利用已知的資訊，便可以加速計算所需的時間。而Z Algorithm便是充分的利用這一點。現在我們就來介紹這個名字很帥氣的演算法。
  首先我們定義Z function
\begin{theorem}[定義]
  對於一個字串$A = a_0 a_1 \cdots a_{n-1}$，定義
  \[
    Z_A(i) = \begin{dcases}
      0, \quad \text{if } i = 0 \text{ or } A[i] \neq A[0] \\
      \max \{ k : A[0, k-1] = A[i, i+k-1] \}, \quad \text{else}
    \end{dcases}
  \]
\end{theorem}
看起來和失敗函數$\fail(i)$有點像，但不一樣的是$Z(i)$表示$A$的後綴$S_A(i)$，也就是從$A[i]$開始的字串，可以和$A$自已匹配多長。舉例來說如果$A = \str{abcabc}$，則$Z(3) = 3$。

現在我們需要一個快速求出所有 $Z(i)$ 的方法，假設我們已經知道了 $Z(i) = z$，也就是 $A[0, z-1] = A[i, i+z-1]$。那麼 $Z(i+1), Z(i+2), \cdots , Z(i+z-1)$ 是否會和 $Z(1), Z(2), \cdots, Z(z-1)$ 有關係呢？
事實上Z function有一個很重要的性質是
\begin{theorem}[定理]
  對於一個字串$A = a_0 a_1 \cdots a_{n-1}$，如果$Z(i) = z$，則
  \begin{itemize}
    \item $A[k] = A[i+k], \quad \text{if } \; 0 \leq k < z$.
    \item $A[z] \neq A[i+z]$. \listeqn \label{eq:z-0}
    \item 令$L = i, R = i + z - 1$，現在假設$L \leq j \leq R, j' = j - L$，則：
      \begin{itemize}
        \item 如果$j' + Z(j') < z $，則 $Z(j) = Z(j')$ \listeqn \label{eq:z-1}
        \item 如果$j' + Z(j') > z$， 則 $Z(j) = R - j + 1$ \listeqn \label{eq:z-2}
        \item 如果$j' + Z(j') = z$， 則 $Z(j) \geq R - j + 1 = Z(j')$ \listeqn \label{eq:z-3}
      \end{itemize}
  \end{itemize}
\end{theorem}
重點是\eqref{eq:z-1}, \eqref{eq:z-2}, \eqref{eq:z-3} 這三個case，我們來好好解釋
\begin{enumerate}[label=Case \arabic*.]
  \item $j' + Z(j') < z$
    \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}[scale=0.8, transform shape]
        \draw[line width=0.5mm] 
        (0, 0) -- (7, 0)
        (0, -.3) -- (0, .3)
        (2, -.2) -- (2, .2)
        (3, -.2) -- (3, .2)
        (7, -.3) -- (7, .3)
        (6, -.2) -- (6, .2)
        (9, 0) -- (16, 0)
        (9, -.3) -- (9, .3)
        (16, -.3) -- (16, .3)
        (10, -.2) -- (10, .2)
        (11, -.2) -- (11, .2)
        (12, -.2) -- (12, .2)
        (15, -.2) -- (15, .2)
        ;

        \draw[line width=0.4mm] 
        (2, 1) -- (5, 1)
        (2, .8) -- (2, 1.2)
        (3, .8) -- (3, 1.2)
        (4, .8) -- (4, 1.2)
        (5, .8) -- (5, 1.2)

        (11, 1) -- (14, 1)
        (11, .8) -- (11, 1.2)
        (12, .8) -- (12, 1.2)
        (13, .8) -- (13, 1.2)
        (14, .8) -- (14, 1.2)
        ;
        \draw[latex-]
        (6.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$z-1$};
        \draw[latex-]
        (2.5, 1.5) -- ++(0, 1) node[above, scale=1.2]{$j'$};
        \draw[latex-]
        (4.5, 1.5) -- ++(0, 1) node[above, scale=1.2, xshift=0.3cm]{$j' + Z(j') - 1$};
        \draw[latex-]
        (9.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$L$};
        \draw[latex-]
        (11.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$j$};
        \draw[latex-]
        (15.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$R$};
      \end{tikzpicture}
    \end{center}
    \caption{}
    \label{fig:}
    \end{figure}

    這種情況因為沒有超出以前計算的範圍，所以我們可以直接用之前的結果，$Z(j) = Z(j')$。
  \item $j' + Z(j') > z$

    \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}[scale=0.8, transform shape]
        \draw[line width=0.5mm] 
        (0, 0) -- (7, 0)
        (0, -.3) -- (0, .3)
        (2, -.2) -- (2, .2)
        (3, -.2) -- (3, .2)
        (7, -.3) -- (7, .3)
        (6, -.2) -- (6, .2)

        (10, 0) -- (17, 0)
        (10, -.3) -- (10, .3)
        (17, -.3) -- (17, .3)
        (11, -.2) -- (11, .2)
        (12, -.2) -- (12, .2)
        (13, -.2) -- (13, .2)
        (16, -.2) -- (16, .2)
        ;
        \draw[line width=0.5mm]
        [dashed] (7, 0) -- (8, 0)
        (8, .2) -- (8, -.2)
        ;

        \draw[line width=0.4mm] 
        (2, 1) -- (8, 1)
        (2, .8) -- (2, 1.2)
        (3, .8) -- (3, 1.2)
        (7, .8) -- (7, 1.2)
        (8, .8) -- (8, 1.2)

        (12, 1) -- (17, 1)
        (12, .8) -- (12, 1.2)
        (13, .8) -- (13, 1.2)
        (16, .8) -- (16, 1.2)
        (17, .8) -- (17, 1.2)
        ;

        \draw[line width=0.4mm, dashed]
        (17, 0) -- (18, 0)
        (18, -.2) -- (18, .2)
        ;
        \draw[latex-]
        (6.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$z-1$};
        \draw[latex-]
        (2.5, 1.5) -- ++(0, 1) node[above, scale=1.2]{$j'$};
        \draw[latex-]
        (7.5, 1.5) -- ++(0, 1) node[above, scale=1.2, xshift=0.3cm]{$j' + Z(j') - 1$};
        \draw[latex-]
        (10.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$L$};
        \draw[latex-]
        (12.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$j$};
        \draw[latex-]
        (16.5, -.5) -- ++(0, -1) node[below, scale=1.2]{$R$};
        \draw[latex-latex]
        (7.5, -.5) |- (17.5, -2.4) -- (17.5, -.5);
        \draw[thick]
        (11.8, -2.2) -- (12.2, -2.6)
        (12.2, -2.2) -- (11.8, -2.6)
        ;
      \end{tikzpicture}
    \end{center}
    \caption{}
    \label{fig:}
    \end{figure}

    這個情況由 \eqref{eq:z-0} 我們會知道$A[j' + Z(j') - 1] \neq A[R+1]$，所以從$j$開始最長也只能匹配到$R$了，因此$Z(j) = R - j + 1$。

  \item $j' + Z(j') = z$
    最後一種情況雖然我們無法直接得出$Z(j)$，但我們至少會知道$Z(j) \geq Z(j')$，因此我們繼續從$R$下去匹配就可以了！
\end{enumerate}

仔細分析了之後我們可以知道，除非是第3種Case才需要計算。假設計算 $Z(j)$ 時用到了第3種Case，我們就把 $(L, R)$ 更新為 $(j, j+Z(j)-1)$，可以發現如這樣做$R$值只會一直增加，且增加次數不可能超過字串的長度，並且匹配的次數恰好就是$R$增加的次數，因此求出所有位置的$Z(i)$時間複雜度只需$\ord{N}$。


不過這和字串匹配有什麼關係呢？假設我們要拿 $B$ 匹配 $A$ ，只要令 $C = B \phi A$，其中 $\phi$ 是從來沒有在 $A, B$ 間出現過的字元，這樣如果 $A[i, i+k-1] = B, \: k = \abs{B}$ ，必有 $C[k+i+1, 2k+i] = C[0, k-1]$ ， 也就是
$ Z_C(k+i+1) = k $。

除此之外 Z algorithm 還可以解決諸如最長回文子字串等等的問題，方法和這裡類似，就留給讀者思考了。
\section{Suffix Array}
Suffix Array 是解決字串問題中的一把很神秘的武器，乍看之下不知道他的用處何在，其實一大半的問題都可以用他來解決。這麼好用的東西一定要把他學起來！\\

\begin{theorem}[定理]
  對於一個字串$B$的兩個不同的後綴$S_B(i), S_B(j)$，必有$S_B(i) \neq S_B(j)$，即
  \[ 
    S_B(i) < S_B(j) \quad \text{or} \quad S_B(i) > S_B(j)
  \]
\end{theorem}
這是理所當然的，因為後綴兩兩不等長。而後綴數組要做的事就是把他們的順序找出來。後綴的順序在最後會給我們許多非常有用的資訊！

首先我們定義一些東西：
\begin{theorem}[定義]
  對於一個長度為$n$的字串$B$，令$S_B = \{ S_B(0), S_B(1), \cdots S_B(n-1)\}$為所有後綴的集合，定義
  \begin{enumerate}
    \item $\rank(i)$表示後綴$S_B(i)$在$S_B$中是字典序第幾小的(從$0$開始算)。
    \item $\sa(i) = \rank^{-1}(i)$，也就是說第$i$小的後綴是哪一個。
    \item $\hei(i) = x$代表$S_{B}(\sa(i))$跟$S_{B}(\sa(i-1))$前$k$個字元相同，也就是說如果$S_{B}(\sa(i)) = S_1, \: S_{B}(\sa(i-1)) = S_2$，則$S_1[0, k-1] = S_2[0, k-1]$。我們特別規定$\hei(0) = 0$。
  \end{enumerate}
\end{theorem}
這邊一定不能搞混，$\rank(i)$表示``$i$是第幾名"，而$\sa(i)$表示``誰是第$i$名"，兩者互為反函數。舉個列子，對於字串 \texttt{"ABAABAAAB"} ：
\begin{center}
\begin{tabular}{c|c|c|l}
  $i$ & $\sa$ & $\hei$ & Suffix \\\hline
  0 & 5 & 0 & AAAB \\
  1 & 6 & 2 & AAB \\
  2 & 2 & 3 & AABAAAB \\
  3 & 7 & 1 & AB \\
  4 & 3 & 2 & ABAAAB \\
  5 & 0 & 4 & ABAABAAAB \\
  6 & 8 & 0 & B \\
  7 & 4 & 1 & BAAAB \\
  8 & 1 & 3 & BAABAAAB
\end{tabular}
\end{center}

在學會如何使用 suffix array 以前，我們得先學會如何建造 suffix array 。而建造 suffix array 的演算法也很多種，最佳的時間複雜度為 $\ord{N}$ 。
但原理複雜，因此這裡我們先介紹一種最基本的倍增算法，複雜度是 $\ord{N \log N } $，但在這之前我們需要一點先備知識。
\begin{theorem}[定理]
  如果$A[0, k-1] = B[0, k-1]$我們便寫作$A =_k B$，相同的道理我們可以定義$A <_k B$，則
  \[ A < B  \quad \Rightarrow  \quad
    \begin{dcases}
      A <_k B &  \text{or} \\
      A =_k B \; \land \; S_A(k) < S_B(k)  &
    \end{dcases}
  \]
\end{theorem}
其實就是說假定今天$A < B$，且$A = A_1A_2, B = B_1B_2, \; \abs{A_1} = \abs{B_1}$，那麼不是$A$在第一階段就比輸了$A_1 < B_1$，就是在第二階段才比輸， $A_1 = B_1 \text{ and } A_2 < B_2$。\\
藉由這個性質，我們可以觀察到一件很重要的事情：如果我們已經知道所有後綴在只比較他們的前 $k$ 個字元時的大小關係，那麼我們其實可以快速的找出比較前 $2k$ 個字元時的大小關係，因為任何後綴的最後$k$個字元也是原本字串的某個後綴的前$k$個字元！因此倍增的做法便是
\begin{enumerate}
    \item 使用某種方法讓所有後綴依照第一個字元排好
    \item 基於上方結果，讓所有後綴依照前 $2$ 個字元排好
    \item 基於上方結果，讓所有後綴依照前 $4$ 個字元排好
    \item ....
    \item 基於上方結果，讓所有後綴依照前 $2^{\lceil\log_2 |A|\rceil}$ 個字元排好
\end{enumerate}
祥細的流程如下，定義$\rank_k(i)$表示依照前 $k$ 個字元排序時，比第$i$個後綴
小的有幾個(也就是名次，只是相等的名次一樣)
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[mynode/.style=draw, minimum width=3cm, minimum height=1cm, align=left]
    \node at (0, 0) [mynode] {先求出$\rank_1(i)$};
    \node at (4.5, 0) [mynode] {用$(\rank_k(i), \rank_k(i+k))$\\排序得出$\sa_{2k}(i)$};
    \node at (9.4, 0) [mynode] {利用$\sa_{2k}$求出$\rank_{2k}$};
    \node at (7.2, 1.2) {總共$\ceil{\lg n}$次};
    \draw[-latex, thick] (1.6, 0) -- ++(0.8, 0);
    \draw[-latex, thick] (6.6, 0) -- ++(0.8, 0);
    \draw[-latex, thick] (9.4, 0) ++ (0, 0.6) |- (4.5, 1.5) -- ++(0, -0.8);
    \draw[-latex, thick] (11.5, 0) -- ++(1, 0);
  \end{tikzpicture}
  \caption{}
  \label{fig:sa1}
\end{figure}
從 Figure~\ref{fig:sa1} 中我們知道瓶頸在排序$(\rank(i), \rank(i+k))$，假設一次的時間複雜度是$\ord{F}$，那總體的複雜度就是$\ord{\log(n) F}$。如果我們用一般的排序法$\ord{F} = \ord{n \log n}$，但因為我們要排的東西都是兩個$[0, n)$中的整數對，可以使用 Radix sort 加速到 $\ord{n}$ ，因此總共的複雜度就是  $\ord{n \log n}$了。

最後我們只剩$\hei$要求了。複習一下$\hei$的定義，$\hei(i)$代表$S_{B}(\sa(i))$跟$S_{B}(\sa(i-1))$前幾個字元相同。我們先列出他的一些性質：
\begin{theorem}[定理]
  我們定義$d(A_1, A_2)$表示$A_1, A_2$的前幾個字元相同。對於一個長度為$n$的字串$B$有：
  \begin{itemize}
    \item 假設$\rank(i) < \rank(j)$，則 $ d(S_B(i), S_B(j)) = \min\limits_{\rank(i) < k \leq \rank(j)} \hei(k) $ \listeqn \label{eq:sa1}
    \item 如果$\hei(\rank(i)) = k$，則字典序比 $S_B(i)$ 小的字串最多只會跟 $S_B(i)$ 前 $k$ 個字元一樣。 \listeqn \label{eq:sa2}
    \item $\hei(\rank(i)) \geq \hei(\rank(i-1)) - 1$ \listeqn \label{eq:sa3}
  \end{itemize}
\end{theorem}
其實按照字典序排序的結果就是，長的像的後綴會被排在一起！
我們先證 \eqref{eq:sa1} ，假設$\rank(i) = k_1, \rank(j) = k_2$，注意到
$\hei(k_2)$ 表示 $S_B(\sa(k_2)), S_B(\sa(k_2-1))$ 前幾個字元一樣，$\hei(k_2 - 1)$ 表示 $S_B(\sa(k_2 - 1)), S_B(\sa(k_2-2))$ 前幾個字元一樣...，一直到 $\hei(k_1 + 1)$ 表示 $S_B(\sa(k_1 + 1)), S_B(\sa(k_1))$ 前幾個字元一樣。但別忘了
\[
  S_B(\sa(k_1)) = S_B(\sa(\rank(i))) = S_B(i),\quad S_B(\sa(k_2)) = S_B(\sa(\rank(j))) = S_B(j)
\]
因此 $S_B(i), S_B(j)$ 至少前$h = \min_{k_1 < k \leq k_2} \hei(k)$個字元一樣！但 $h = \min_{k_1 < k \leq k_2} \hei(k)$，表示一定有一次 $S_B(\sa(k')) $ 和 $S_B(\sa(k'-1))$的第$h$個字元不一樣。而之後這第 $h$ 個字元也不可能一樣，因為我們是照字典序排序的，接下來只會越來越小！因此 \eqref{eq:sa1} 是對的！\\
\eqref{eq:sa2} 是 \eqref{eq:sa1} 的一個直接的結果，而 \eqref{eq:sa3} 我們用圖來說明 \\

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=0.8]
    \fill[gray!30] (1, 0) rectangle (5, 1);
    \fill[gray!30] (8, 0) rectangle (12, 1);
    \draw[line width=0.8mm] (0, 0) rectangle (5, 1);
    \draw[line width=0.8mm] (7, 0) rectangle (12, 1);
    \draw (0, 0) rectangle (14, 1);
    \draw[thick] (0, 0) rectangle (1, 1) coordinate[midway](v1);
    \draw[thick] (1, 0) rectangle (2, 1);
    \draw[thick] (7, 0) rectangle (8, 1) node[midway, yshift=-0.8cm] {$i-1$};
    \draw[thick] (8, 0) rectangle (9, 1) node[midway, yshift=-0.8cm] {$i$};
    \draw (0, 0) rectangle (14, 1);
    \draw[decoration={brace, raise=1.5mm, amplitude=1.5mm}, decorate, thick] (0, 1) -- (5, 1)
    node[midway, yshift=0.7cm] {$\hei(\rank(i-1))$};

    \draw[decoration={brace, raise=1.5mm, amplitude=1.5mm}, decorate, thick] (8, 1) -- (12, 1)
    node[midway, yshift=0.7cm] {$\hei(\rank(i-1)) - 1$}
    ;

    \draw[latex-] (v1) ++ (0, -0.7) -- ++(0, -0.6) node[below]{$\sa(\rank(i-1)-1)$};
    
  \end{tikzpicture}
\caption{}
\label{fig:sa2}
\end{figure}

如Figure~\ref{fig:sa2}，假設$\hei(\rank(i-1)) = k$，且不妨假設$k > 1$，也就是說$S_{B}(i-1)$和他照字典序排序後的前一號$j = \sa(\rank(i-1)-1)$的前$k$個字元一樣！則$S_B(j+1) < S_B(i)$因為$S[j] = S[i-1]$，且$S_B(j+1)$至少會和$S_B(i)$有$k-1$個字元一樣。由\eqref{eq:sa2}我們得知
\[
  \hei(\rank(i)) \geq k - 1 = \hei(\rank(i-1)) - 1 
\]

\subsection{Suffix Array 之應用}
第一個 Suffix Array 主要的應用是處理匹配問題，而且他往往比前面介紹的演算法更有彈性！ 

我們用 $B$ 去匹配 $A$ 其實就是在問 $B$ 是不是 $A$ 的一個子字串。 注意到一個子字串又一定是某個後綴的前綴，所以我們要做的事情就是找出 $A$ 和 $B$ 最像的後綴，也就是{\bf 問如果我們將$A$的後綴排序好後， $B$ 在其中的哪個位置？}而排序的部分剛好就是Suffix Array 做的事情。 而找出 $B$ 在其中的位置，很顯然會想到二分搜。 這樣的確只需要比較 $\ord{n \log n}$ 次，不過因為後綴的長度可以到 $\ord{n}$ ，所以整體下來會是 $\ord{n \log n}$。

一個優化是，假設我們已經將 $B$ 和一個 $A$ 的後綴 $S_A(i)$ 匹配了前 $k$ 個字元， 現在我們要匹配另一個後綴 $S_A(i')$ ， 注意到如果 $B$ 可以和 $S_A(i')$ 匹配超過 $k$ 個字元，那麼 $S_A(i), S_A(i')$ 至少要前 $k$ 個字元相同 (更甚者，要恰好前 $k$ 個字元相同)。也就是 $d(S_A(i), S_A(i')) \geq k$。於是 \eqref{eq:sa1} 告訴了我們
\[ d(S_A(i), S_A(i')) = \min\limits_{\rank_A(i) < k \leq \rank(i')} \hei(k) \]
這其是一個RMQ問題，如果我們用如{\bf 線段樹}等資料結構加速，每一次的查詢只需要 $\ord{\log n}$  甚至 $\ord{1}$ \footnote{ 因為我們不需修改操作，其實 RMQ 是可以做到 $\ord{1}$ 的，當然，不是很好實做。 }。
而如果查詢的結果是 $d(S_A(i), S_A(i')) < k$ ，我們就不需要在重新匹配了，而如果 $d(S_A(i), S_A(i')) = k$ 時我們直接繼續從第 $k$ 個字元匹配。 這樣成功匹配的數量(也差不多會是匹配的次數) 永遠只會增加， 因此匹配的次數不會超過 $\ord{\abs{B}}$ ， 全部的複雜度會是 $\ord{ \abs{A} \log \abs{A} + \abs{B} }$。

第二個應用可以處理字串中的計數問題，我們先考慮一個最基本的問題
\SampleProblem[經典問題]{不同的子字串數}{ 給你一個字串 $A$ ，問$A$不同的子字串有幾個。比如 $A = \str{abab}$，不同的子字串有 $\str{a}, \str{b}, \str{ab}, \str{ba}, \str{aba}, \str{bab}, \str{abab}$，共 $7$ 種。}
這邊還是用到一個子字串一定是一個後綴的前綴。如果一個子字串出現在多個後綴，我們在字典序最小的後綴計算，你會發現，$\hei(i)$就會剛好是$\rank(i)$的後綴的前綴中，有多少已經在字典序比他小的後綴出現過。因此
\[ {n \choose 2} - \sum_{i=1}^{n-1} \hei(i) , \quad \text{where } n = \abs{A} \]
恰好就是答案。

\section{Suffix Automaton*}
後綴字動機 (Suffix Automaton) 是現在很熱門的一個後綴結構。雖然大部分 Suffix Automaton 可以做到的事情 Suffix Array 也可以做到，但其程式碼精簡，不失為另一個不錯的解題武器。

\begin{theorem}[定義]
  一個字串$B$的後綴自動機是一個自動機，他接受一個字串$s$若且唯若$s$是$B$的一個後綴。
\end{theorem}
如下圖 \ref{fig:sam1} 就是字串$\str{abcbc}$的後綴自動機。
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[>=latex, node distance=2cm, auto]
    \tikzstyle{accepting}=[fill=gray!20, double=gray!20, double distance = 1.5pt]
    \node[state, initial] (q0) {};
    \node[state] (q1) [right of=q0]{};
    \node[state] (q2) [right of=q1]{};
    \node[state] (q3) [right of=q2]{};
    \node[state] (q4) [right of=q3]{};
    \node[state, accepting] (q5) [right of=q4]{};
    \node[state] (q6) [above right of=q1, yshift=1cm, xshift=-1cm]{};
    \node[state, accepting] (q7) [right of=q6, xshift=1cm]{};
    \path[->]
    (q0) edge [swap] node {a} (q1)
    (q1) edge [swap] node {b} (q2)
    (q2) edge [swap] node {c} (q3)
    (q3) edge [swap] node {b} (q4)
    (q4) edge [swap] node {c} (q5)
    (q0) edge        node {b} (q6)
    (q0) edge        node {c} (q7)
    (q6) edge        node {c} (q7)
    (q7) edge        node {b} (q4)
    ;
  \end{tikzpicture}
\caption{}
\label{fig:sam1}
\end{figure}
至於如何構造？最基本的想法就是把所有$B$的{\bf 子字串}都當作自動機上的一個 state，然後一個一個 state 慢慢建邊。這樣當然正確性是被保證的(畢竟所有後綴的前綴一定是原字串的一個子字串)，但這樣 state 有 $\ord{N^2}$ 個，需要再改進。\\
而減少 state 的唯一方法就是把等價的 state 合併。像 Figure~\ref{fig:sam1} 中 state 數量也只有 $8$ 個而非 ${6 \choose 2} = 15$ 個那麼多，觀察後可以發現在圖中 $\str{abcb},\str{bcb},\str{cb}$ 三個字串是屬於同一個 state 的！\\
仔細思考一陣後可以發現，只要結束位置相同的兩個子字串，他們的 state 就會是等價的，我們便可以將之合併！我們先定義結束集合

\begin{theorem}[定義]
  給定兩個字串$B, T$，我們定義$T$在$B$上的結束集合$\edps_B(T)$為
  \[
    \edps_B(T) = \{ i ~:  B[ i - \abs{T} + 1 , i ] = T \}
  \]
\end{theorem}
比如說對$\str{abcbc}$而言，$\edps(\str{bc}) = \{2, 4\}$，因為$\str{bc}$在字串中出現兩次並且分別在位置$2, 4$結束。

\begin{theorem}[定理]
  給定兩個字串$T_1, T_2$，如果$\edps_B(T_1) = \edps_B(T_2)$，記作$T_1 \equiv_B T_2$，則
  \begin{itemize}
    \item 對任何字串$A$，$\edps_B(T_1 A) = \edps_B(T_2 A)$，也就是$T_1 A \equiv_B T_2 A$ \listeqn \label{eq:sam1}
    \item 對任何字串$A$，如果$T_1 A$是$B$的後綴，則$T_2 A$也是$B$的後綴 \listeqn \label{eq:sam2}
  \end{itemize}
\end{theorem}

\eqref{eq:sam1} 稍為推敲即可得出，而 \eqref{eq:sam2} 是前者的一個直接推論，並且 \eqref{eq:sam2} 也告訴我們，只要 $T_1 \equiv_B T_2$，他們的確可以看作是等價的 state ！如在前面的例子，$\edps(\str{bc}) = \{2, 4\} = \edps(\str{c})$，而他們在 Figure~\ref{fig:sam1} 上也的確會走到同一個 state 。\\
但這樣可以幫我們省下多少 state 呢？ 我們還需要$\edps$的一個很重要的性質：

\begin{theorem}[定理]
  給定兩個字串$T_1, T_2$，$\abs{T_1} < \abs{T_2}$，那麼不是
  $ \edps(T_1) \cap \edps(T_2) = \varnothing $，就是
  $ \edps(T_1) \supset \edps(T_2) $。並且如果是後者，$T_1$會是$T_2$的一個後綴。 \listeqn
\end{theorem} 
事實上從這個定理我們就可以知道state的數量最多只會有 $2n - 1$ 個。我們在這邊整理一下：\\

\begin{theorem}[定理]
  我們可以用 $\equiv_B$ 將 $B$ 的所有子字串分類，也就是$T_1, T_2$被分在同一類若且唯若 $T_1 \equiv_B T_2$ 。假設我們將 $B$ 的所有子字串分成 $\alpha_1, \alpha_2 , \cdots , \alpha_k$，則
  \begin{itemize}
    \item 如果$t_1, t_2 \in \alpha_i$，則必有其中一個為另一個的後綴。 \listeqn \label{eq:sam3}
    \item $k$ 恰好是後綴自動機上非起始節點的數量，每一個$\alpha_i$可以看做是後綴自動機上的一個 state 。
    \item $k < 2 |B| - 1$。
  \end{itemize}
\end{theorem}

在後綴自動機還有一個很重要的指標，Fail link $\flk$。假設一個字串 $T_0$ 是 $B$ 的子字串，那我們如果不斷把 $T_0$ 的第一個字串去掉變成 $T_1, T_2, \cdots$，那一開始結束集合可能不變，但總會有一個 $T_k$ 結束集合開始改變了。 比如說 $B = \str{ababa}$ ， $\str{abab}, \str{bab}$ 的結束集合都是 $\{ 4 \}$ ，但 $\str{ab}$ 的結束集合變成 $\{ 2, 4 \}$ 了。\\
假設 $T_0$ 所屬的集合稱作 $\alpha_1$ ， $T_k$ 所屬的集合稱作 $\alpha_2$ ，則令 $\flk(\alpha_1) = \alpha_2$。

\begin{theorem}[定理]
  我們定義 $\edps(\alpha_i) = \edps(t_1)$，對於任意一個 $t_i \in \alpha_i$。(反正任何一個的結束集合都一樣)。\\
  定義 $\max(\alpha_i), \min(\alpha_i)$為$\alpha_i$裡最長/短的字串(因為 \eqref{eq:sam3} 所以恰好只會有一個)。\\
  我們用$\alpha(t)$來表示字串$t$所屬的集合，如果$s_i = \min(\alpha_i)$，我們定義
  \[
    \flk(\alpha_i) = \alpha(S_{s_i}(1))
  \]
  也就是把$s_i$的第一個字元去掉後所屬的類別。
\end{theorem}

現在我們要考慮怎麼樣把這一個後綴自動機建出來。一個做法是我們從空字串開始，一個一個字元慢慢加上去。因為$\alpha_i$就是後綴自動機上的點，所以我們要先了解$\edps(t)$會怎麼變動。
\begin{theorem}[定理]
  給定$B$，現在如果在$B$的後面加一個字元$c$使得$B' = Bc$，則如果$T$是$B$的一個子字串，有
  \begin{itemize}
    \item 如果$T$不是$B'$的一個後綴，那$\edps_{B'}(T) = \edps_B(T)$。
    \item 如果$T$是$B'$的一個後綴，那$\edps_{B'}(T) = \edps_B(T) \cap \{n\}$，其中$n = \abs{B} = \abs{B'} - 1$。
  \end{itemize}
\end{theorem}
這個定理告訴我們，在一個字串後面加一個字元，結束集合不會有太大的變動！會變的只有$B'$的後綴，不超過$n$個，而且分在同一類的可以一起處理！現在的問題就只有{\bf 怎麼找出所有後綴存在的集合了}。這時候就可以好好利用 $\flk$ 了！

\begin{theorem}[定理]
  給定一個字串$B$，$B'$ 為在 $B$ 後面加一個字元 $c$ 所成的字串， 即 $B' = B c $ 。
  \begin{itemize}
    \item 假設 $T'$ 是 $B'$ 的後綴， 則 $B = Tc$，其中 $T$ 是 $B$ 的後綴。
      \listeqn  \label{eq:bc1}
    \item 令 $\beta_0 = \alpha(B)$ ， 也就是整個字串 $B$ 所屬的集合，如果  $\flk(\beta_i) = \beta_{i+1}$ ， 則所有 $B$ 的後綴都會在 $\{ \beta_0, \beta_1, \cdots, \beta_h \}$的其中一個。 \listeqn \label{eq:bc2}
  \end{itemize}
\end{theorem}

將 \eqref{eq:bc1} 和 \eqref{eq:bc2} 合起來用，我們就得出一個找到 $B'$ 所有後綴的方法了！ 我們只要檢查 $\{ \beta_0, \beta_1, \cdots \}$ 有沒有連出 $c$ 的邊，有的話所有那些點就是 $B'$ 的後綴了。最後我們只要考慮這些點的結束位置會怎麼變就可以了。

\begin{theorem}[定理]
  給定一個字串$B$：%
  \begin{itemize}
    \item 現在如果在$B$的後面加一個字元$c$使得$B' = Bc$，則如果$T$是$B'$的後綴，且$T$是$B$的子字串，那$T$的所有後綴也是$B$的子字串。     
    \item 存在$k$使得所有$j \geq k$，$S_B(j) c$，也就是在$S_B(j)$後面加一個字元$c$，都是$B$的子字串。而所有$j < k$，$S_B(j) c$都不是$B$的子字串。\listeqn \label{eq:bc3}
  \end{itemize}
\end{theorem}
也就是說會有一個臨界的後綴$S = S_B(k)$，使得比他短的後綴加上 $c$ 後，會是原本 $B$ 的子字串。不妨設 $m = \abs{S}$。令 $\beta_k$ 是第一個有連出 $c$ 的邊的點，由 \eqref{eq:bc3} 我們知道 $\beta_i$ 有連出 $c$ 的邊若且唯若 $i \geq k$。因此可令 $\gamma_i = \beta_i c$，也就是從$\beta_i$連出 $c$ 的邊走到的點。我們現在只要考慮 $\edps(\gamma_i)$，會怎麼變化就可以了！有兩種情形


\begin{enumerate}[label=Case \arabic*. ]
  \item $\abs{\max(\gamma_i)} = \abs{\max(\beta_i)} + 1$，假設 $\max(\beta_i) = T, \max(\gamma_i) = U$，這代表 $Tc = U$ ，而 $\gamma_i$ 裡的字串都是$U$ 的後綴，也就是 {\bf 所有 $\gamma_i$ 中的字串都是 $B' = Bc$ 的後綴}！因此他們的結束位置都全部加一個 $n$，同時改變，不需要分家了。
  \item $\abs{\max(\gamma_i)} > \abs{\max(\beta_i)} + 1$，與前面的 Case 相反，這表示 {\bf 並非所有 $\gamma_i$ 中的字串都是 $B' = Bc$ 的後綴}！這時我們勢必得把 $\gamma_i$ 拆成兩個新的點 $\gamma_{i1}, \gamma_{i2}$ 了。
\end{enumerate}

因此我們必需維護兩個東西，$\flk(\alpha_i)$ 和 $\mx(\alpha_i) = \abs{\max(\alpha_i)}$。
如果你仔細考慮每個 Case 這兩者該如何變化，可以得出以下構造後綴自動機的演算法：\\
我們從一個只有 initial state $\alpha_0$ 的自動機開始，每個點維護$\flk(\alpha_i), \mx(\alpha_i) = \abs{\max(\alpha_i)}$，並且記好結束的 state $e$ 是哪一個(一開始$e = \alpha_0$)，逐一插入字元。假設這一次插入的字元為 $c$ ：
\begin{enumerate}
  \item 加入一個新點 $\alpha_{k+1}$
  \item 從$e$開始，令$u = e$。看看 $u$ 有沒有 $c$ 的出去的邊，如果沒有，則加一條 $c$ 從 $u \rightarrow \alpha_{k+1}$的邊。 令 $u \leftarrow \flk(u)$ 繼續嘗試，直到有或者 $u = \alpha_0$為止。
  \item 如果$u$沒有 $c$ 連出去的邊，則$u = \alpha_0$，加一條 $c$ 從 $\alpha_0 \rightarrow \alpha_{k+1}$並令$\flk(\alpha_{k+1}) = \alpha_0$後結束。
  \item  現在假設$u$ 從 $c$ 連出去的邊到 $v$。
  \item 如果$\mx(v) = \mx(u) + 1$，(Case 1.)則讓$\flk(\alpha_{k+1}) = v$，結束。
  \item 如果$\mx(v) \neq \mx(u) + 1$，(Case 2.)我們需要把$v$拆成兩個點。因此我們複製一個點$v'$使得
    \begin{itemize}
      \item $v'$要保持$v$的所有向外的邊。
      \item $\flk(v') \leftarrow \flk(v), \quad \flk(v), \flk(\alpha_{k+1}) \leftarrow v'$。
      \item 所有$u$往$\flk(u)$走到的節點如果有邊指向$v$要改指到$v'$。因此我們不段令$u \leftarrow \flk(u)$去檢查，直到$u = \alpha_0$為止。
    \end{itemize}
\end{enumerate}
最後更新$e = \alpha_{k+1}$，增加$k$後重複步驟直到建完整個字串。\\
以下是一個 Suffix Automaton 的範例程式碼：
Suffix Automata 的應用非常多，從匹配到計數等等。另外 Suffix Automata 有一個很重要的性質：
\begin{theorem}[定理]
  一個 $B$ 的後綴自動機上從起始點 $s$ 到任何一點 $v$ 的任何一條路徑都恰好對應到一個 $B$ 的子字串。
\end{theorem}
因此會有各種在 Suffix Automata 上 DP 的花招，就留給讀者自行探討了。

\section{習題}

  %\setcounter{subsection}{-1}
  %\subsection{Preliminary}
    %\ExerciseProblem[基本知識]{String in C/C++}{
      %俗話說的好，工欲善其事，必先利其器。在學習任何字串演算法前，也要先熟悉C/C++裡的字串操作，不然題目來了還是無從下手！而字串的儲存可以用\texttt{char} Array, 也可以用C++裡的\texttt{std::string}，請熟悉這兩種的各種操作，輸入/出，以及相關的內建函數(如比較函數等等)。並指出下面程式的問題所在。
    %}
    
  \subsection{String Matching}
    \ExerciseProblem[經典問題]{ABA}{
    給定字串$S$，求出最長的$A$使得$S = ABA$。$\cons{\ord{\abs{S}}}$
    }

    \ExerciseProblem[POI XIII]{Periods of Words}{
      給定字串$S$，求出最長的$A$使得 $A$ 是 $S$ 的前綴且 $S$ 是 $AA$ 的前綴。$\cons{\abs{S} \leq 10^6}$
    }

    \ExerciseProblem[POI XII]{Template}{
      給定字串$S$，求出最短的$A$使得 $A$ 可以覆蓋 $S$ 。 比如說 $\str{abaabaab}$ 可以用兩個 $\str{abaab}$ ，分別開頭在 $0, 3$ 蓋住。$\cons{\abs{S} \leq 10^6}$
    }

    \ExerciseProblem[經典問題]{近似匹配}{
      給定字串$A, B$，以及一個整數$k$，求出所有$B$在$A$中$k$幾乎匹配的位置。我們稱$A[i, i+n-1], B[j, j+n-1]$是$k$幾乎匹配如果$\{ A[i+x] \neq B[j+x], \: 0 \leq x \leq n-1 \}$的個數不超過$k$個。 $\cons{\ord{k\abs{A} + \abs{B}}}$
    }

    \ExerciseProblem[TIOJ 1735 / Kelvin]{k-口吃子字串}{
      定義一個$k$-口吃字串為某一個長度為 $k$ 的字串重複兩次的字串。如 $\str{abcabc}, \str{aaaaaa}$ 都是 $3$-口吃字串。給一個字串$S$和 $k$ ，請問有多少 $(i, j)$ 滿足 $S[i, j]$ 是 $k$-口吃字串。  \\
      $\cons{\abs{S} \leq 10^5}$ 
    }

    \ExerciseProblem[經典問題]{KMP and Z value}{
      給你一個字串的 fail function $\fail$ 和他的長度 $n$ (也就是說你並不知道原本的字串) ，請求出他的 Z value $Z$ 。 
      反之亦然，給你一個字串的 Z value $Z$ ，請求出他的 fail function $\fail$ 。 
      $\cons{ \ord{n} }$
    }

    \ExerciseProblem[TIOJ 1725]{Massacre at Camp Happy}{
      定義兩個字串$A, B$是$k$-幾乎相同如果把 $A$ 的前 $k$ 個字元搬到最後面，那兩者恰相差一個字元，給你 $A, B$ ， 求出所有的 $k$ 使得他們是 $k$-幾乎相同。 $\cons{ \abs{A} = \abs{B} \leq 10^6 }$
    }

    \newcommand{\ZZ}{\operatorname{\mathcal{Z}}}
    \ExerciseProblem[經典問題]{最長回文子字串}{
      給一個字串 $A$ ，求出他最長的一個回文子字串。 $ \cons{ \ord{ \abs{A}} }$

      這題可以用類似 Z-algorithm 的方法。我們先考慮如何求最長的{\bf 奇數}回文子字串。 令 $\ZZ(i)$表示以$i$為中心最長的回文字串為 $A[i-\ZZ(i), i+\ZZ(i)]$。 現在假設$(L, R) = (i-\ZZ(m), i+\ZZ(m))$, 即$A[L, R]$是一個以$a[m]$ 為中心的回文。如果 $j \in [m+1, R]$，考慮 $j' = 2m - j$，即$j$對$m$的反射點。現在與Z-algorithm類似，令 $L' = j - \ZZ(j')$，分別考慮 $L' > L, L' = L , L' < L$ 三種情況。

      但此方法僅能求得奇數的回文長度。因此我們把原字串相鄰的兩個字元都插入一個不在字元集 $\Sigma$ 中的字元，如 $A = \str{abbab} \; \rightarrow A' = 
  \str{a\$b\$b\$a\$b}$，這樣所有回文的長度都變成奇數了。
    }

    \ExerciseProblem[Codeforces Zlobober's blog]{Anti-hash text}{
      在 Hashing 實作上，因為 C++ 的模運算 \texttt{\%} 是非常花時間的，因此有一種 Lazy hash 的方法是 直接 $\bmod{2^{32}}$ 或是 $\bmod{2^{64}}$，這樣直接在 $\texttt{int}, \texttt{long long}$ 下做運算就可以了。但這樣做有其風險在，以下說明其原因。

      不妨假設此 Hash function 為
      \[ f(A) = \sum_{i=0}^{n-1} a_i p^{n-1-i} \bmod{q} \]
      其中 $p$ 為一奇數(否則此 Hash function 無意義)，$q = 2^m$，並且 $\str{a}, \str{b}$ 轉換成數字後分別為 $\alpha, \alpha + 1$ 。此時令
      \[ A_0 = \str{a}, \quad A_j = \widetilde{A}_{j-1} A_{j-1} \]
      其中 $\widetilde{A}$ 表示把字串 $A$ 中的 $\str{a}$ 換成 $\str{b}$， $\str{b}$ 換成 $\str{a}$。如：
      \[ A_1 = \str{ba}, \quad A_2 = \str{abba}, \quad A_3 = \str{baababba}, \quad \cdots \]
      現在考慮 $A_{k}, \widetilde{A}_{k}$，注意這兩個字串恰好是 $A_{k+1}$ 的前後半且 $A_k \neq \widetilde{A}_{k}$。請證明
      \begin{align*}
        f(\widetilde{A}_{k}) - f(A_{k}) &= p^0 - p^1 - p^2 + p^3 -p^4 + p^5 + \cdots + (-1)^{k-1} p^{2^{k}-1} \\
        &= \sum_{i=0}^{2^{k}-1} b_i p^i  \quad = S
      \end{align*}
      其中 $b_i \in \{ 1, -1 \}$，且如果 $i$ 的二進位表示有偶數個 $1$ ，則 $b_i = 1$，否則 $b_i = 0$。並且有
      \[ \sum_{i=0}^{2^{k}-1} b_i p^i = (p-1)(p^2-1)(p^4-1) \cdots (p^{2^{k-1}} - 1) \]
      注意到 $(p^{2^r} - 1)$ 可以被 $2^{r+1}$ 整除 (Why?) ，所以 $S$ 可以被 $2^{1 + 2 + \cdots + k} = 2^{k (k+1)/2}$整除。因此只要 $2^{k(k+1)/2}$ 被 $2^m$ 整除，也就是$\frac{k(k+1)}{2} > m$，$A_{k}$ 和 $\widetilde{A}_{k}$ 的 Hash value 就會相同。因此可以用一個長度為 $2^{\ord{x}}$ 的字串構造出一個使 $q = 2^{\ord{x^2}}$ 的 Hash function 失效的反例，並且與 $p$ 的選擇無關。
    } 

    \ExerciseProblem[經典問題]{二維匹配}{
      給你一個 $R_A \times C_A$ 的二維字串 $A$ ， 問一個 $R_B \times C_B$ 的二維字串 $B$ 有沒有出現在其中？ $\cons{ \ord{ R_A C_A + R_B C_B }}$。

      一個巧妙的做法可參考 Baker-Bird Algorithm，令外也有用 Hash 的方法，令$c = C_B, \; a_i[j] = f(A[i][j, j+c-1])$，原題等價於問 $f(B[0]), f(B[1]), \cdots f(B[R_B-1])$ 是不是等於\\ 
      $a_i[j], a_{i+1}[j], \cdots , a_{i+R_B-1}[j]$。這是一個一維的匹配問題。詳細可參考去年的講義。
    }

    \ExerciseProblem[ACM ICPC 2013-2014 NEERC Northern Subregional]{sed}{
      給你$A, B$，求出字串 $X, Y$ 使得將 $A$ 中的 $X$ 取代為 $Y$ 後會變成 $B$，並且 $\abs{X} + \abs{Y}$ 最短。 取代的定義為找 $X$ 出現在 $A$ 的第一個位置，假設 $A[i, j] = X$ ，立刻將 $A[i, j]$ 變成 $Y$ ，並從 $j+1$ 繼續找下一個 $X$ 直到沒有為止。 $\cons{ \abs{A}, \abs{B} \leq 5000}$。
    }

  \subsection{Suffix structure}
    \ExerciseProblem[經典問題]{最小的後綴}{
      給一個字串 $A$ ，求出他字典序最小的後綴。 $\cons{\ord{\abs{A}}}$

      有不需要建出Suffix Array的方法。 \footnote{Hint: 雙指針}

      這有一些應用，如最小循環表示法。 有時候我們會把一個狀態或物體用一個字串表示，並且可能旋轉需視為相同的，也就是把字串前 $k$ 個字元接到後面視為相同。 這時候如果要比較兩個字串，可以先求他們的最小循環表示在進行比較。
    }

    \ExerciseProblem[經典問題]{重複子字串}{
      給一個字串 $A$ ，求出他最長的一個重複的子字串，重複的部分可以重疊。比如說 $A = \str{cabababc}$，最長的重複子字串為 $\str{aba}$。 $ \cons{ \ord{ \sa } }$ \footnote{ $\ord{ \sa }$ 表示建出後綴數組所需的時間。} \\
      如果改成不能重複呢？ $\cons{ \ord{ \abs{A} \log \abs{A} } }$
    }

    \ExerciseProblem[經典問題]{連續重複的子字串}{
      給一個字串 $A$ ，求出他的連續重複次數最多的子字串。比如說 $A = \str{cababababc}$， $\str{ab}$在子字串$\str{abababab}$中連續重複了$4$次。
    } $\cons{ \ord{ \abs{A} \log \abs{A} } }$

    \ExerciseProblem[ASC 40]{Binary Suffix Array}{
      給定一個 $n$ 個整數的序列 $a_1, a_2, \cdots, a_n$， 找出一個01字串 $A$ 使得 $A$ 的後綴數組 $\sa$
      恰好是給定的序列，注意到有可能無解。
    } $\cons{ \abs{A} \leq 3 \cdot 10^5}$

    \ExerciseProblem[SPOJ 7258]{Lexicographical Substring Search}{
      給一個字串 $A$ ，現在把 $A$ 的所有子字串列出，將重複的刪去後排序。對於 $Q$ 比詢問， 輸出字典序第 $k$ 小的子字串。
    } $\cons{ \abs{A} \leq 90000, Q \leq 500}$

    \ExerciseProblem[NTUOJ 2200]{Beautiful Substring}{
      給一個字串 $A$ ， 把他所有不同的子字串找出來，令這個集合為 $S$ ，接著每次會給一個字串 $B_i$， 假設他所有不同的子字串的集合為 $T_i$， 就令 $S \leftarrow S \setminus T_i$，並輸出此時的 $\abs{S}$，也就是 $S$ 裡還剩多少字串。
    } $\cons{ \abs{A} \leq 2 \times 10^5,\; \sum \abs{B_i} \leq 10^6}$

    \ExerciseProblem[ASC 42]{Incomparable Suffixes}{
      給一個字串 $A$ ， 我們說兩個字串 $s, t$ 是{\bf 可分辨的} 若且為若存在一個字串 $z$ 使得 $sz, tz$ 中恰好只有一個是
      $A$ 的後綴， 說兩個字串 $s, t$ 是 {\bf 無可比較的} 若且為若對所有 $s$ 的前綴 $x$ ， $t$ 的前綴 $y$ ， 
      $x, y$ 都是可分辨的。 現在請找出 $a_1, a_2, \cdots, a_n$ 滿足：
      \begin{enumerate}
        \item 所有 $a_i$ 都是 $A$ 的後綴。
        \item $n$ 越大越好。
        \item 在 $n$ 是所有可能的最大值下， $\sum \abs{a_i}$ 越大越好。
      \end{enumerate}
    } $\cons{ \abs{A} \leq 10^5}$
  \section{Special Thanks}
  此分講義部分參考自去年的講義，特別感謝去年的編輯者。
\end{document}
